#!/bin/sh

# Version 2.1.1
# Скрипт для запуска sing-box на роутерах Asus с прошивкой Мерлина и установленным на USB носителе Entware.

# Переменные
JFFS_SB_DIR="/jffs/addons/sing-box-script"
SB_CONFIG="$JFFS_SB_DIR/config.json"
SCRIPT_PATH="$JFFS_SB_DIR/sbs"
TEMP_UPDATE="$JFFS_SB_DIR/temp-update"
SBS_CONF="$JFFS_SB_DIR/sbs-conf"
SBS_MON="$JFFS_SB_DIR/sbs-monitor"
LANG_RU="$JFFS_SB_DIR/sbs-lang-ru"
LANG_EN="$JFFS_SB_DIR/sbs-lang-en"
SCRIPT_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/sbs"
SB_CONFIG_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/config.json"
LANG_RU_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/sbs-lang-ru"
LANG_EN_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/sbs-lang-en"
ROOT_DIR="/opt/root"
SB_DIR="$ROOT_DIR/sing-box"
SB_PATH="$SB_DIR/sing-box"
SB_URL="https://api.github.com/repos/SagerNet/sing-box/releases/latest"
SB_DOWNLOAD_DIR="$SB_DIR/sing-box-download"
SB_ARCHIVE64_PATH="$SB_DOWNLOAD_DIR/sing-box-linux-arm64.tar.gz"
SB_ARCHIVE_PATH="$SB_DOWNLOAD_DIR/sing-box-linux-armv7.tar.gz"
TEMP_SBS_CONF="/jffs/scripts/sbs-conf"
TEMP_LANG_RU="/jffs/scripts/sbs-lang-ru"
TEMP_LANG_EN="/jffs/scripts/sbs-lang-en"
FW_SCRIPT="/jffs/scripts/firewall-start"
NAT_SCRIPT="/jffs/scripts/nat-start"
SS_SCRIPT="/jffs/scripts/services-start"
SS_LINES="(sleep 45 && $SCRIPT_PATH start) &"
LN_PATH="/opt/bin/sbs"

# Функции
log_msg() {
    echo "$1"
    logger -t "sbs" "$1"
}

create_dir() {
    mkdir -p "$1"
    chmod 775 "$1"
    printf "$MESSAGE1\n" "$1"
}

create_sbs_conf() {
    cat << EOF > "$1"
# Создан в SBS 2.1.1
# Этот файл создаётся автоматически и значения в него вводятся через консоль роутера при выполнении определённых пунктов в меню, вызываемых командами 'sbs setup', 'sbs update' или 'sbs server'. Не рекомендуется изменять значения в нём напрямую, в обход перечисленных команд.
# Если вы всё же хотите изменить здесь значения напрямую, то перед этим обязательно остановите sing-box с помощью команды 'sbs stop' в консоли роутера, иначе вам не избежать неприятных багов, от которых без специальных познаний будет сложно избавиться.
#
# Строка DEVICE_IPS - тут между кавычками указываются IP-адреса устройств, трафик которых вы хотите направить через sing-box. IP-адреса должны быть в одну строку и между ними должно быть только по одному пробелу. Так же тут можно указать и подсеть в формате CIDR, например 192.168.50.0/24. Значения задаются в первом пункте меню 'sbs setup'.
# Строка EXC_DEVICE_IPS - если в строке DEVICE_IPS указана подсеть, то тут можно указать IP-адреса устройств из этой подсети, трафик которых вы хотите исключить из направления через sing-box. Так же тут можно указать подсеть меньшего размера, которая входит в указанную в DEVICE_IPS, если это соответствует вашим целям. Значения задаются в первом пункте меню 'sbs setup'.
# Строка DEVICE_FIPS - тут между кавычками указываются IP-адреса устройств, которые вы хотите заставить работать через fakeip. В остальном аналогично строке DEVICE_IPS. Значения задаются в меню 'sbs setup', только если в файле конфигурации config.json присутствуют настройки fakeip.
# Строка EXC_DEVICE_FIPS - если в строке DEVICE_FIPS указана подсеть, то тут можно указать IP-адреса устройств из этой подсети, которые вы хотите исключить из работы через fakeip. В остальном аналогично строке EXC_DEVICE_IPS. Значения задаются в меню 'sbs setup', только если в файле конфигурации config.json присутствуют настройки fakeip.
# Строка ROUTE_TABLE - если указанный в ней по умолчанию номер таблицы маршрутизации 5553 уже занят в вашем роутере, что маловероятно, можете заменить его на другой, который не занят. Значения задаются в меню 'sbs setup' в подменю продвинутых настроек.
# Строка TPROXY_MARK - если указанный в ней по умолчанию fwmark 0x4d3c2b1a уже занят в вашем роутере, что маловероятно, можете заменить его на другой, который не занят. Значения задаются в меню 'sbs setup' в подменю продвинутых настроек.
# Строка WAN_PORTS - при старте sing-box указанные в ней порты будут открыты для доступа из WAN в роутер. Не открывайте порты из интернета в свой роутер без осознанной необходимости. Открытие не тех портов может привести к потере всех данных в вашей домашней сети. Значения задаются в меню 'sbs server'.
# Строка LANG - если указать значение "ru", то все сообщения от скрипта будут на русском языке, а если "en"- на английском. Значения задаются в меню 'sbs lang'.
# Строка SB_REPO - тут указывается какой репозиторий использовать для загрузки ядра sing-box. Значения "original", "customa" или "customb" задаются при выборе репозитория в 3-м пункте меню 'sbs update' и соответствуют официальному или двум кастомным репозиториям.
# Строки CUSTOM_REPO_A и CUSTOM_REPO_B - в них указываются кастомные репозитории ядра sing-box в формате "имя_github_профиля/наименование_репозитория", например "Dr4tez/sing-box-mod". Задаются в 3-м пункте меню 'sbs update'.
# Строки TUN_INTERFACE, TPROXY_PORT, LISTEN_DNS_PORT и FAKEIP_SUBNET - их значения автоматически извлекаются из конфигурационного файла sing-box и записываются сюда.

DEVICE_IPS=""
EXC_DEVICE_IPS=""
DEVICE_FIPS=""
EXC_DEVICE_FIPS=""
ROUTE_TABLE="5553"
TPROXY_MARK="0x4d3c2b1a"
WAN_PORTS=""
LANG=""
SB_REPO="original"
CUSTOM_REPO_A="Dr4tez/sing-box-mod"
CUSTOM_REPO_B=""
TUN_INTERFACE=""
TPROXY_PORT=""
LISTEN_DNS_PORT=""
FAKEIP_SUBNET=""
EOF
    chmod 664 "$1"
}

create_sbs_monitor() {
    script_path="$1"
    script_content='#!/bin/sh
# Создан в SBS 2.1.1

source "/jffs/addons/sing-box-script/sbs-conf"

if [ -n "$DEVICE_IPS" ]; then
    m_sorted_all=$(echo "$DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}" | tr " " "\n" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$"; echo "$DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}" | tr " " "\n" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+" | sort -t "/" -k2,2nr)
    m_sorted_subnets=$(echo "$DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS}" | tr " " "\n" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+" | sort -t "/" -k2,2n)
fi

m_update_script() {
    [ -f "$1" ] || { echo "#!/bin/sh" > "$1"; chmod 755 "$1"; }
    echo "$2" | while IFS= read -r line; do
        grep -qF "$line" "$1" || echo "$line" >> "$1"
    done
}

m_get_main_ips() {
    ip -4 route show | awk "{print \$1}" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/[0-9]+)?$" | while read addr; do
        case "$addr" in
            */*) echo "$addr" ;;
            *) echo "$addr/32" ;;
        esac
    done
}

m_ip_to_int() {
    IFS=. read -r o1 o2 o3 o4 <<EOF
$1
EOF
    echo $(( (o1 << 24) + (o2 << 16) + (o3 << 8) + o4 ))
}
m_mask_bits_to_int() {
    bits="$1"
    echo $(( 0xFFFFFFFF << (32 - bits) & 0xFFFFFFFF ))
}
m_parse_cidr() {
    case "$1" in
        */*) IFS=/ read -r ip bits <<EOF
$1
EOF
            ;;
        *) ip="$1"
           bits=32
           ;;
    esac
    ip_int=$(m_ip_to_int "$ip")
    mask=$(m_mask_bits_to_int "$bits")
    net=$(( ip_int & mask ))
    echo "$ip_int $bits $mask $net"
}
m_cidr_in_cidr() {
    cidr_a="$1"
    cidr_b="$2"

    set -- $(m_parse_cidr "$cidr_a")
    a_ip="$1"
    a_bits="$2"
    a_mask="$3"
    a_net="$4"

    set -- $(m_parse_cidr "$cidr_b")
    b_ip="$1"
    b_bits="$2"
    b_mask="$3"
    b_net="$4"

    [ "$a_bits" -lt "$b_bits" ] && return 1

    if [ "$(( a_net & b_mask ))" -eq "$b_net" ]; then
        return 0
    else
        return 1
    fi
}
route_in_process=0

sbs_monitor_rr() {
  { ip monitor route | while read _; do
        if [ "$route_in_process" -eq 0 ]; then
            route_in_process=1
            if ! ps | grep "[s]ing-box.*run" >/dev/null 2>&1; then
                "/opt/root/sing-box/sing-box" run -c "/jffs/addons/sing-box-script/config.json" &
            fi
            if [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; }; then
                if [ -n "$TUN_INTERFACE" ]; then
                    ip route add default dev $TUN_INTERFACE table $ROUTE_TABLE 2>/dev/null
                    if [ -n "$DEVICE_IPS" ]; then
                        ip route show table main | grep -v "^default" | while read ROUTE; do
                            ip route add $ROUTE table $ROUTE_TABLE 2>/dev/null
                        done
                        ip route show table $ROUTE_TABLE | grep -v "^default" | while read ROUTE; do
                            if ! ip route show table main | grep -q "^$ROUTE"; then
                                ip route del $ROUTE table $ROUTE_TABLE 2>/dev/null
                            fi
                        done
                    fi
                elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                    ip route add local 0.0.0.0/0 dev lo table $ROUTE_TABLE 2>/dev/null
                    sed -i "/sing-box-script-mangle/d" /jffs/scripts/nat-start
                    iptables -t mangle -D PREROUTING -j SBTPROXY  2>/dev/null
                    iptables -t mangle -F SBTPROXY 2>/dev/null
                    iptables -t mangle -N SBTPROXY 2>/dev/null
                    iptables -t mangle -I PREROUTING -j SBTPROXY
                    m_update_script /jffs/scripts/nat-start "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBTPROXY  2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBTPROXY 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBTPROXY 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBTPROXY # sing-box-script-mangle"
                    if [ -n "$m_sorted_subnets" ]; then
                        echo "$m_sorted_subnets" | while read -r subnet; do
                            if echo "$DEVICE_IPS" | grep -qw "$subnet"; then
                                iptables -t mangle -I SBTPROXY -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                                iptables -t mangle -I SBTPROXY -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBTPROXY -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle"
                            elif echo "$EXC_DEVICE_IPS" | grep -qw "$subnet"; then
                                iptables -t mangle -I SBTPROXY -s $subnet -j RETURN
                                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBTPROXY -s $subnet -j RETURN # sing-box-script-mangle"
                            elif [ -n "$FAKEIP_SUBNET" ] && echo "$DEVICE_FIPS" | grep -qw "$subnet"; then
                                matchedm=0
                                for subnetm in $DEVICE_IPS; do
                                    if cidr_in_cidr "$subnet" "$subnetm"; then
                                        iptables -t mangle -I SBTPROXY -s $subnet -j RETURN
                                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBTPROXY -s $subnet -j RETURN # sing-box-script-mangle"
                                        matchedm=1
                                        break
                                    fi
                                done
                                if [ "$matchedm" -eq 0 ]; then
                                    continue
                                fi
                            fi
                        done
                    fi
                    if ipset list sbsexc-ipsetm >/dev/null 2>&1; then
                        iptables -t mangle -I SBTPROXY -m set --match-set sbsexc-ipsetm src -j RETURN
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBTPROXY -m set --match-set sbsexc-ipsetm src -j RETURN # sing-box-script-mangle"
                    fi
                    if ipset list sbsinc-ipsetm >/dev/null 2>&1; then
                        iptables -t mangle -I SBTPROXY -p tcp -m set --match-set sbsinc-ipsetm src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                        iptables -t mangle -I SBTPROXY -p udp -m set --match-set sbsinc-ipsetm src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBTPROXY -p tcp -m set --match-set sbsinc-ipsetm src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp -m set --match-set sbsinc-ipsetm src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle"
                    fi
                    if [ -n "$FAKEIP_SUBNET" ]; then
                        iptables -t mangle -I SBTPROXY -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                        iptables -t mangle -I SBTPROXY -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBTPROXY -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle"
                    fi
                    iptables -t mangle -I SBTPROXY -p tcp --dport 53 -j RETURN
                    iptables -t mangle -I SBTPROXY -p udp --dport 53 -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBTPROXY -p tcp --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp --dport 53 -j RETURN # sing-box-script-mangle"
                    m_get_main_ips | while read mainip; do
                        iptables -t mangle -I SBTPROXY -d $mainip -j RETURN
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBTPROXY -d $mainip -j RETURN # sing-box-script-mangle"
                    done
                    iptables -t mangle -I SBTPROXY -p udp --dport 67 -j RETURN
                    iptables -t mangle -I SBTPROXY -p udp --dport 68 -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBTPROXY -p udp --dport 67 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp --dport 68 -j RETURN; ) & # sing-box-script-mangle"
                fi
            fi
            if [ -n "$ROUTE_TABLE" ] && [ -n "$FAKEIP_SUBNET" ] && [ -z "$DEVICE_IPS" ] && [ -z "$DEVICE_FIPS" ]; then
                if [ -n "$TUN_INTERFACE" ]; then
                    ip route add default dev $TUN_INTERFACE table $ROUTE_TABLE 2>/dev/null
                elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                    ip route add local 0.0.0.0/0 dev lo table $ROUTE_TABLE 2>/dev/null
                    sed -i "/sing-box-script-mangle/d" /jffs/scripts/nat-start
                    iptables -t mangle -D PREROUTING -j SBTPROXY  2>/dev/null
                    iptables -t mangle -F SBTPROXY 2>/dev/null
                    iptables -t mangle -N SBTPROXY 2>/dev/null
                    iptables -t mangle -I PREROUTING -j SBTPROXY
                    m_update_script /jffs/scripts/nat-start "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBTPROXY  2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBTPROXY 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBTPROXY 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBTPROXY # sing-box-script-mangle"
                    iptables -t mangle -I SBTPROXY -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                    iptables -t mangle -I SBTPROXY -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBTPROXY -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK; ) & # sing-box-script-mangle"
                fi
            fi; route_in_process=0
        fi
    done } &

    while true; do
        ip monitor rule | while read line; do
            if [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; }; then
                if [ -n "$TUN_INTERFACE" ]; then
                    if [ -n "$FAKEIP_SUBNET" ]; then
                        if ! ip rule show | grep -q "to $FAKEIP_SUBNET lookup $ROUTE_TABLE"; then
                            ip rule add to $FAKEIP_SUBNET lookup $ROUTE_TABLE priority 553
                        fi
                    fi
                    if [ -n "$DEVICE_IPS" ]; then
                        for IP in $DEVICE_IPS; do
                            ip rule del from $IP lookup $ROUTE_TABLE >/dev/null 2>&1
                        done
                        for IP in $EXC_DEVICE_IPS; do
                            ip rule del from $IP lookup main >/dev/null 2>&1
                        done
                        for IP in $DEVICE_FIPS; do
                            ip rule del from $IP lookup main >/dev/null 2>&1
                        done
                        echo "$m_sorted_all" | while read -r IP; do
                            if echo "$DEVICE_IPS" | grep -qw "$IP"; then
                                ip rule add from "$IP" lookup "$ROUTE_TABLE" priority 553
                            elif [ -n "$FAKEIP_SUBNET" ] && echo "$DEVICE_FIPS" | grep -qw "$ip"; then
                                matched=0
                                for subnet in $DEVICE_IPS; do
                                    if m_cidr_in_cidr "$ip" "$subnet"; then
                                        ip rule add from "$ip" lookup main priority 553
                                        matched=1
                                        break
                                    fi
                                done
                                if [ "$matched" -eq 0 ]; then
                                    continue
                                fi
                            else
                                ip rule add from "$IP" lookup main priority 553
                            fi
                        done
                    fi
                elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                    if ! ip rule show | grep -q "from all fwmark ${TPROXY_MARK%%/*} lookup $ROUTE_TABLE"; then
                        ip rule add fwmark $TPROXY_MARK lookup $ROUTE_TABLE priority 553
                    fi
                fi
            fi
            if [ -n "$ROUTE_TABLE" ] && [ -n "$FAKEIP_SUBNET" ] && [ -z "$DEVICE_IPS" ] && [ -z "$DEVICE_FIPS" ]; then
                if [ -n "$TUN_INTERFACE" ]; then
                    if ! ip rule show | grep -q "to "$FAKEIP_SUBNET" lookup $ROUTE_TABLE"; then
                        ip rule add to "$FAKEIP_SUBNET" lookup $ROUTE_TABLE priority 553
                    fi
                elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                    if ! ip rule show | grep -q "from all fwmark ${TPROXY_MARK%%/*} lookup $ROUTE_TABLE"; then
                        ip rule add fwmark $TPROXY_MARK lookup $ROUTE_TABLE priority 553
                    fi
                fi
            fi; break
        done
    done
}

trap "" SIGHUP
(
    while true; do
        if ! ps | grep "[s]ing-box.*run" >/dev/null 2>&1; then
            "/opt/root/sing-box/sing-box" run -c "/jffs/addons/sing-box-script/config.json" &
        fi
        sleep 5
    done
) &
sbs_monitor_rr 2>/dev/null
'
    echo "$script_content" > "$script_path"
    chmod +x "$script_path"
}

check_file_existence_and_download() {
    local file_path="$1"
    local file_url="$2"
    local file_name=$(basename "$file_path")

    if [ -f "$file_path" ]; then
        printf "$MESSAGE2\n" "$file_name"
        while true; do
            read -p "$MESSAGE3" choice
            case $choice in
                0) printf "$MESSAGE4\n" "$file_name"; return 0 ;;
                1) printf "$MESSAGE5\n" "$file_name"; wget -q -O "$file_path" "$file_url"; return 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        printf "$MESSAGE7\n" "$file_name"
        wget -q -O "$file_path" "$file_url"
    fi
}

delete_if_not_current_dir() {
  local current_dir=$(dirname "$(readlink -f "$0")")

  if [ "$current_dir" != "$JFFS_SB_DIR" ]; then
    rm -f "$(readlink -f "$0")"
  fi
}

create_or_use_existing() {
    local dir_path="$1"

    if [ -d "$dir_path" ]; then
        printf "$MESSAGE8\n" "$dir_path"
        while true; do
            read -p "$MESSAGE9" choice
            case $choice in
                0) delete_if_not_current_dir; rm -f $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN; echo "$MESSAGE10"; exit 0 ;;
                1) printf "$MESSAGE11\n" "$dir_path"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        create_dir "$dir_path"
    fi
}

handle_existing_file() {
    local file_path="$1"
    local create_function="$2"

    if [ -f "$file_path" ]; then
        printf "$MESSAGE2\n" "$file_path"
        while true; do
            read -p "$MESSAGE12" choice
            case $choice in
                0) echo "$MESSAGE13"; break ;;
                1) printf "$MESSAGE14\n" "$file_path"; "$create_function" "$file_path"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        "$create_function" "$file_path"
    fi
}

check_copy_file() {
    local src_file="$1"
    local dst_file="$2"

    if [ -f "$dst_file" ]; then
        printf "$MESSAGE2\n" "$dst_file"
        while true; do
            read -p "$MESSAGE12" choice
            case $choice in
                0) echo "$MESSAGE13"; break ;;
                1) [ -f "$src_file" ] && printf "$MESSAGE14\n" "$dst_file" && cp "$src_file" "$dst_file"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        [ -f "$src_file" ] && cp "$src_file" "$dst_file"
    fi
}

change_language() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi

    while true; do
        if [ "$LANG" = "ru" ]; then
            echo "Перейти на английский?"
            read -p "$MESSAGE18" choice
            case "$choice" in
                0) echo "$MESSAGE66"; break ;;
                1) [ -f "$LANG_EN" ] || { wget -q -O $LANG_EN $LANG_EN_URL && chmod 664 $LANG_EN; }; source "$LANG_EN"; sed -i 's/^LANG=".*"/LANG="en"/' "$SBS_CONF"; echo "$MESSAGE188"; exit 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        elif [ "$LANG" = "en" ]; then
            echo "Switch to Russian?"
            read -p "$MESSAGE18" choice
            case "$choice" in
                0) echo "$MESSAGE66"; break ;;
                1) [ -f "$LANG_RU" ] || { wget -q -O $LANG_RU $LANG_RU_URL && chmod 664 $LANG_RU; }; source "$LANG_RU"; sed -i 's/^LANG=".*"/LANG="ru"/' "$SBS_CONF"; echo "$MESSAGE188"; exit 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        fi
    done
}

update_script() {
    [ -f "$1" ] || { echo "#!/bin/sh" > "$1"; chmod 755 "$1"; }
    echo "$2" | while IFS= read -r line; do
        grep -qF "$line" "$1" || echo "$line" >> "$1"
    done
}

manage_iptables() {
    if [ "$1" = "add" ]; then
        iptables -C $2 2>/dev/null || iptables -I $2 || log_msg "$(printf "$MESSAGE15\n" "$2")"
    elif [ "$1" = "remove" ]; then
        iptables -C $2 2>/dev/null && iptables -D $2 || log_msg "$(printf "$MESSAGE16\n" "$2")"
    fi
}

is_running() {
    ps | grep -v grep | grep -q "$SB_PATH"
}

get_sbs_version() {
    sed -n '3s/^# Version //p' "$1"
}

get_sb_versplat() {
    local vers plat

    vers=$("$1" version | awk '/^sing-box version/ {print $3}' | head -n 1)
    plat=$("$1" version | awk '/^Environment:/ {print $3}' | head -n 1)
    echo "$vers $plat"
}

get_sb_version() {
    local version

    version=$("$1" version | awk '/^sing-box version/ {print $3}' | head -n 1)
    echo "$version"
}

self_copy() {
    local destination="$1"
    cp "$0" "$destination"
}

silent_create_dir() {
    mkdir -p "$1"
    chmod 775 "$1"
}

sing_box_start() {
    echo "$MESSAGE17"
    while true; do
        read -p "$MESSAGE18" choice
        case "$choice" in
            0) echo "$MESSAGE19"; break ;;
            1) start_sing_box; break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

update_tun_interface() {
    tun_interface=""
    in_block=0
    block=""

    while IFS= read -r line; do
        case "$line" in
            *'{'*) 
                block="$line"
                in_block=1
                continue ;;
        esac

        if [ "$in_block" -eq 1 ]; then
            block="$block
$line"
            case "$line" in
                *'}'*) 
                    in_block=0
                    echo "$block" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"tun\"" || continue
                    echo "$block" | grep -q '^[[:space:]]*"interface_name"[[:space:]]*:' || continue
                    tun_interface=$(echo "$block" | sed -n 's/^[[:space:]]*"interface_name"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p')
                    [ -n "$tun_interface" ] && break ;;
            esac
        fi
    done < "$SB_CONFIG"

    if [ -z "$tun_interface" ]; then
        sed -i "s/^TUN_INTERFACE=.*/TUN_INTERFACE=\"\"/" "$SBS_CONF"
    else
        sed -i "s/^TUN_INTERFACE=.*/TUN_INTERFACE=\"$tun_interface\"/" "$SBS_CONF"
    fi
}

extract_listen_port() {
    var_name="$1"
    type_value="$2"
    listen_port=""
    in_block=0
    block=""

    while IFS= read -r line; do
        case "$line" in
            *'{'*) 
                block="$line"
                in_block=1
                continue ;;
        esac

        if [ "$in_block" -eq 1 ]; then
            block="$block
$line"
            case "$line" in
                *'}'*) 
                    in_block=0
                    echo "$block" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"$type_value\"" || continue
                    echo "$block" | grep -q '^[[:space:]]*"listen_port"[[:space:]]*:' || continue
                    listen_port=$(echo "$block" | sed -n 's/^[[:space:]]*"listen_port"[[:space:]]*:[[:space:]]*\([0-9]*\).*/\1/p')
                    [ -n "$listen_port" ] && break ;;
            esac
        fi
    done < "$SB_CONFIG"

    if [ -z "$listen_port" ]; then
        sed -i "s/^$var_name=.*/$var_name=\"\"/" "$SBS_CONF"
    else
        sed -i "s/^$var_name=.*/$var_name=\"$listen_port\"/" "$SBS_CONF"
    fi
}

fakeip_check() {
    found_block=0
    enabled_required=0
    enabled_found=0
    inet4_range=""
    in_block=0

    while IFS= read -r line || [ -n "$line" ]; do
        if [ $in_block -eq 0 ]; then
            if echo "$line" | grep -q '^[[:space:]]*"fakeip"[[:space:]]*:[[:space:]]*{' ; then
                in_block=1
                found_block=1
                enabled_required=1
                enabled_found=0
                inet4_range=""
                continue
            fi
            if echo "$line" | grep -q '^[[:space:]]*"type"[[:space:]]*:[[:space:]]*"fakeip"'; then
                in_block=1
                found_block=1
                enabled_required=0
                enabled_found=1
                inet4_range=""
                continue
            fi
        else
            echo "$line" | grep -q '}' && in_block=0
            if [ $in_block -eq 0 ]; then
                break
            fi
            if [ $enabled_required -eq 1 ]; then
                echo "$line" | grep -q '^[[:space:]]*"enabled"[[:space:]]*:[[:space:]]*true' && enabled_found=1
            fi
            if echo "$line" | grep -q '^[[:space:]]*"inet4_range"[[:space:]]*:'; then
                inet4_range=$(echo "$line" | sed -n 's/^[[:space:]]*"inet4_range"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
            fi
        fi
    done < "$SB_CONFIG"

    if [ $found_block -eq 1 ] && [ $enabled_found -eq 1 ] && [ -n "$inet4_range" ]; then
        sed -i "s|^FAKEIP_SUBNET=.*|FAKEIP_SUBNET=\"$inet4_range\"|" "$SBS_CONF"
    else
        sed -i "s|^FAKEIP_SUBNET=.*|FAKEIP_SUBNET=\"\"|" "$SBS_CONF"
    fi
}

ip_to_int() {
    IFS=. read -r o1 o2 o3 o4 <<EOF
$1
EOF
    echo $(( (o1 << 24) + (o2 << 16) + (o3 << 8) + o4 ))
}

mask_bits_to_int() {
    bits="$1"
    echo $(( 0xFFFFFFFF << (32 - bits) & 0xFFFFFFFF ))
}

parse_cidr() {
    case "$1" in
        */*) IFS=/ read -r ip bits <<EOF
$1
EOF
            ;;
        *) ip="$1"
           bits=32
           ;;
    esac
    ip_int=$(ip_to_int "$ip")
    mask=$(mask_bits_to_int "$bits")
    net=$(( ip_int & mask ))
    echo "$ip_int $bits $mask $net"
}

cidr_in_cidr() {
    cidr_a="$1"
    cidr_b="$2"

    set -- $(parse_cidr "$cidr_a")
    a_ip="$1"
    a_bits="$2"
    a_mask="$3"
    a_net="$4"

    set -- $(parse_cidr "$cidr_b")
    b_ip="$1"
    b_bits="$2"
    b_mask="$3"
    b_net="$4"

    [ "$a_bits" -lt "$b_bits" ] && return 1

    if [ "$(( a_net & b_mask ))" -eq "$b_net" ]; then
        return 0
    else
        return 1
    fi
}

get_main_ips() {
    ip -4 route show | awk '{print $1}' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/[0-9]+)?$' | while read addr; do
        case "$addr" in
            */*) echo "$addr" ;;
            *) echo "$addr/32" ;;
        esac
    done
}

start_sing_box() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi

    echo ""
    is_running && { log_msg "$MESSAGE21"; exit 1; }

    all_entries=$(printf "%s\n" $DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS})
    duplicates=$(echo "$all_entries" | sort | uniq -d)
    if [ -n "$duplicates" ]; then
        printf "$MESSAGE190\n" "$duplicates"
        exit 1
    fi

    log_msg "$MESSAGE200"
    update_tun_interface
    extract_listen_port LISTEN_DNS_PORT direct
    extract_listen_port TPROXY_PORT tproxy
    check_wan_ports
    fakeip_check
    source "$SBS_CONF"

    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; }; then
        sorted_subnets=$(echo "$DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS}" | tr ' ' '\n' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+' | sort -t '/' -k2,2n)
        sorted_all=$(echo "$DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}" | tr ' ' '\n' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$'; echo "$DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}" | tr ' ' '\n' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+' | sort -t '/' -k2,2nr)
    fi

    if [ -n "$TUN_INTERFACE" ]; then
        FW_RULES="FORWARD -i $TUN_INTERFACE -j ACCEPT
        FORWARD -o $TUN_INTERFACE -j ACCEPT
        INPUT -i $TUN_INTERFACE -j ACCEPT
        OUTPUT -o $TUN_INTERFACE -j ACCEPT"
        lsmod | grep -q "^tun " || { log_msg "$MESSAGE22"; modprobe tun; sleep 3; }
    elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
        lsmod | grep -q "^xt_TPROXY " || { log_msg "$MESSAGE191"; modprobe xt_TPROXY; sleep 3; }
    fi

    log_msg "$MESSAGE20"
    $SB_PATH run -c $SB_CONFIG &
    sleep 5
    is_running || { log_msg "$MESSAGE201"; exit 1; }

# Проверка наличия tun интерфейса
    if [ -n "$TUN_INTERFACE" ]; then
        if ip link show "$TUN_INTERFACE" >/dev/null 2>&1; then
            log_msg "$(printf "$MESSAGE23\n" "$TUN_INTERFACE")"
        else
            log_msg "$MESSAGE24"
        fi
    fi
# Добавление правил nat и обновление скрипта nat-start
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; } && [ -n "$LISTEN_DNS_PORT" ]; then
        sed -i "/sing-box-script/d" "$NAT_SCRIPT"
        iptables -t nat -D PREROUTING -j SBS-TNAT 2>/dev/null
        iptables -t nat -F SBS-TNAT 2>/dev/null
        iptables -t nat -N SBS-TNAT 2>/dev/null
        iptables -t nat -I PREROUTING -j SBS-TNAT
        update_script "$NAT_SCRIPT" "( sleep 15 # sing-box-script-nat
iptables -t nat -D PREROUTING -j SBS-TNAT 2>/dev/null # sing-box-script-nat
iptables -t nat -F SBS-TNAT 2>/dev/null # sing-box-script-nat
iptables -t nat -N SBS-TNAT 2>/dev/null # sing-box-script-nat
iptables -t nat -I PREROUTING -j SBS-TNAT # sing-box-script-nat"
        has_no_slash=0
        for IP in $DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}; do
            if ! echo "$IP" | grep -q '/'; then
                has_no_slash=1
                break
            fi
        done
        if [ $has_no_slash -eq 1 ]; then
            ipset create sbsinc-ipset hash:ip
            for IP in $DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}; do
                if ! echo "$IP" | grep -q '/'; then
                    ipset add sbsinc-ipset "$IP"
                fi
            done
        fi
        exchas_no_slash=0
        for IP in $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$EXC_DEVICE_FIPS}; do
            if ! echo "$IP" | grep -q '/'; then
                exchas_no_slash=1
                break
            fi
        done
        if [ $exchas_no_slash -eq 1 ]; then
            ipset create sbsexc-ipset hash:ip
            for IP in $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$EXC_DEVICE_FIPS}; do
                if ! echo $IP | grep -q '/'; then
                    ipset add sbsexc-ipset $IP
                fi
            done
        fi
        log_msg "$MESSAGE25"
        if [ -n "$sorted_subnets" ]; then
            echo "$sorted_subnets" | while read -r subnet; do
                if echo "$DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}" | grep -qw "$subnet"; then
                    iptables -t nat -I SBS-TNAT -p tcp -s $subnet --dport 53 -j REDIRECT --to-port $LISTEN_DNS_PORT
                    iptables -t nat -I SBS-TNAT -p udp -s $subnet --dport 53 -j REDIRECT --to-port $LISTEN_DNS_PORT
                    update_script "$NAT_SCRIPT" "iptables -t nat -I SBS-TNAT -p tcp -s $subnet --dport 53 -j REDIRECT --to-port $LISTEN_DNS_PORT # sing-box-script-nat
iptables -t nat -I SBS-TNAT -p udp -s $subnet --dport 53 -j REDIRECT --to-port $LISTEN_DNS_PORT # sing-box-script-nat"
                else
                    iptables -t nat -I SBS-TNAT -s $subnet -j RETURN
                    update_script "$NAT_SCRIPT" "iptables -t nat -I SBS-TNAT -s $subnet -j RETURN # sing-box-script-nat"
                fi
            done
        fi
        if ipset list sbsexc-ipset >/dev/null 2>&1; then
            iptables -t nat -I SBS-TNAT -m set --match-set sbsexc-ipset src -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t nat -I SBS-TNAT -m set --match-set sbsexc-ipset src -j RETURN # sing-box-script-nat"
        fi
        if ipset list sbsinc-ipset >/dev/null 2>&1; then
            iptables -t nat -I SBS-TNAT -p tcp -m set --match-set sbsinc-ipset src --dport 53 -j REDIRECT --to-port $LISTEN_DNS_PORT
            iptables -t nat -I SBS-TNAT -p udp -m set --match-set sbsinc-ipset src --dport 53 -j REDIRECT --to-port $LISTEN_DNS_PORT
            update_script "$NAT_SCRIPT" "iptables -t nat -I SBS-TNAT -p tcp -m set --match-set sbsinc-ipset src --dport 53 -j REDIRECT --to-port $LISTEN_DNS_PORT # sing-box-script-nat
iptables -t nat -I SBS-TNAT -p udp -m set --match-set sbsinc-ipset src --dport 53 -j REDIRECT --to-port $LISTEN_DNS_PORT # sing-box-script-nat"
        fi
        update_script "$NAT_SCRIPT" ") & # sing-box-script-nat"
# Добавление правил mangle и обновление скрипта nat-start
        if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ] && [ -n "$TPROXY_MARK" ]; then
            log_msg "$MESSAGE192"
            iptables -t mangle -D PREROUTING -j SBTPROXY 2>/dev/null
            iptables -t mangle -F SBTPROXY 2>/dev/null
            iptables -t mangle -N SBTPROXY 2>/dev/null
            iptables -t mangle -I PREROUTING -j SBTPROXY
            update_script "$NAT_SCRIPT" "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBTPROXY 2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBTPROXY 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBTPROXY 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBTPROXY # sing-box-script-mangle"
            has_no_slashm=0
            for IP in $DEVICE_IPS; do
                if ! echo "$IP" | grep -q '/'; then
                    has_no_slashm=1
                    break
                fi
            done
            if [ $has_no_slashm -eq 1 ]; then
                ipset create sbsinc-ipsetm hash:ip
                for IP in $DEVICE_IPS; do
                    if ! echo "$IP" | grep -q '/'; then
                        ipset add sbsinc-ipsetm "$IP"
                    fi
                done
            fi
            exchas_no_slashm=0
            for IP in $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}; do
                if ! echo "$IP" | grep -q '/'; then
                    exchas_no_slashm=1
                    break
                fi
            done
            if [ $exchas_no_slashm -eq 1 ]; then
                ipset create sbsexc-ipsetm hash:ip
                for IP in $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}; do
                    if ! echo $IP | grep -q '/'; then
                        ipset add sbsexc-ipsetm $IP
                    fi
                done
            fi
            if [ -n "$sorted_subnets" ]; then
                echo "$sorted_subnets" | while read -r subnet; do
                    if echo "$DEVICE_IPS" | grep -qw "$subnet"; then
                        iptables -t mangle -I SBTPROXY -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                        iptables -t mangle -I SBTPROXY -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBTPROXY -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle"
                    elif echo "$EXC_DEVICE_IPS" | grep -qw "$subnet"; then
                        iptables -t mangle -I SBTPROXY -s $subnet -j RETURN
                        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBTPROXY -s $subnet -j RETURN # sing-box-script-mangle"
                    elif [ -n "$FAKEIP_SUBNET" ] && echo "$DEVICE_FIPS" | grep -qw "$subnet"; then
                        matchedm=0
                        for subnetm in $DEVICE_IPS; do
                            if cidr_in_cidr "$subnet" "$subnetm"; then
                                iptables -t mangle -I SBTPROXY -s $subnet -j RETURN
                                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBTPROXY -s $subnet -j RETURN # sing-box-script-mangle"
                                matchedm=1
                                break
                            fi
                        done
                        if [ "$matchedm" -eq 0 ]; then
                            continue
                        fi
                    fi
                done
            fi
            if ipset list sbsexc-ipsetm >/dev/null 2>&1; then
                iptables -t mangle -I SBTPROXY -m set --match-set sbsexc-ipsetm src -j RETURN
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBTPROXY -m set --match-set sbsexc-ipsetm src -j RETURN # sing-box-script-mangle"
            fi
            if ipset list sbsinc-ipsetm >/dev/null 2>&1; then
                iptables -t mangle -I SBTPROXY -p tcp -m set --match-set sbsinc-ipsetm src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                iptables -t mangle -I SBTPROXY -p udp -m set --match-set sbsinc-ipsetm src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBTPROXY -p tcp -m set --match-set sbsinc-ipsetm src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp -m set --match-set sbsinc-ipsetm src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle"
            fi
            if [ -n "$FAKEIP_SUBNET" ]; then
                iptables -t mangle -I SBTPROXY -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                iptables -t mangle -I SBTPROXY -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBTPROXY -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle"
            fi
            iptables -t mangle -I SBTPROXY -p tcp --dport 53 -j RETURN
            iptables -t mangle -I SBTPROXY -p udp --dport 53 -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBTPROXY -p tcp --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp --dport 53 -j RETURN # sing-box-script-mangle"
            get_main_ips | while read mainip; do
                iptables -t mangle -I SBTPROXY -d $mainip -j RETURN
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBTPROXY -d $mainip -j RETURN # sing-box-script-mangle"
            done
            iptables -t mangle -I SBTPROXY -p udp --dport 67 -j RETURN
            iptables -t mangle -I SBTPROXY -p udp --dport 68 -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBTPROXY -p udp --dport 67 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp --dport 68 -j RETURN; ) & # sing-box-script-mangle"
        fi
    fi
# То же, но для использования sing-box в качестве чисто DNS сервера с fakeip для конечных устройств или для AGH, попросили такую возможность
    if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ] && [ -n "$ROUTE_TABLE" ] && [ -z "$DEVICE_IPS" ] && [ -z "$DEVICE_FIPS" ] && [ -n "$LISTEN_DNS_PORT" ] && [ -n "$FAKEIP_SUBNET" ] && [ -n "$TPROXY_MARK" ]; then
        log_msg "$MESSAGE192"
        sed -i "/sing-box-script/d" "$NAT_SCRIPT"
        iptables -t mangle -D PREROUTING -j SBTPROXY 2>/dev/null
        iptables -t mangle -F SBTPROXY 2>/dev/null
        iptables -t mangle -N SBTPROXY 2>/dev/null
        iptables -t mangle -I PREROUTING -j SBTPROXY
        update_script "$NAT_SCRIPT" "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBTPROXY 2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBTPROXY 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBTPROXY 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBTPROXY # sing-box-script-mangle"
        iptables -t mangle -I SBTPROXY -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
        iptables -t mangle -I SBTPROXY -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK
        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBTPROXY -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK # sing-box-script-mangle
iptables -t mangle -I SBTPROXY -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $TPROXY_MARK; ) & # sing-box-script-mangle"
    fi
# Добавление правил файрвола, маршрутов и правил маршрутизации и обновление скрипта firewall-start
    if [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; }; then
        if [ -n "$TUN_INTERFACE" ]; then
            log_msg "$MESSAGE26"
            echo "$FW_RULES" | while read -r rule; do
                manage_iptables "add" "$rule"
                update_script "$FW_SCRIPT" "iptables -I $rule # sing-box-script"
            done
            log_msg "$MESSAGE27"
            ip route add default dev $TUN_INTERFACE table $ROUTE_TABLE
            ip route show table main | grep -v '^default' | while read ROUTE; do ip route add $ROUTE table $ROUTE_TABLE; done
            if [ -n "$FAKEIP_SUBNET" ]; then
                ip rule add to "$FAKEIP_SUBNET" lookup $ROUTE_TABLE priority 553
            fi
            if [ -n "$DEVICE_IPS" ]; then
                echo "$sorted_all" | while read -r ip; do
                    if echo "$DEVICE_IPS" | grep -qw "$ip"; then
                        ip rule add from "$ip" lookup "$ROUTE_TABLE" priority 553
                    elif [ -n "$FAKEIP_SUBNET" ] && echo "$DEVICE_FIPS" | grep -qw "$ip"; then
                        matched=0
                        for subnet in $DEVICE_IPS; do
                            if cidr_in_cidr "$ip" "$subnet"; then
                                ip rule add from "$ip" lookup main priority 553
                                matched=1
                                break
                            fi
                        done
                        if [ "$matched" -eq 0 ]; then
                            continue
                        fi
                    else
                        ip rule add from "$ip" lookup main priority 553
                    fi
                done
            fi
        elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
            log_msg "$MESSAGE27"
            ip route add local 0.0.0.0/0 dev lo table $ROUTE_TABLE
            ip rule add fwmark $TPROXY_MARK lookup $ROUTE_TABLE priority 553
        fi
        $SBS_MON &
    fi
# То же, но для использования sing-box в качестве чисто DNS сервера с fakeip для конечных устройств или для AGH, попросили такую возможность
    if [ -n "$ROUTE_TABLE" ] && [ -n "$FAKEIP_SUBNET" ] && [ -z "$DEVICE_IPS" ] && [ -z "$DEVICE_FIPS" ]; then
        if [ -n "$TUN_INTERFACE" ]; then
            log_msg "$MESSAGE26"
            echo "$FW_RULES" | while read -r rule; do
                manage_iptables "add" "$rule"
                update_script "$FW_SCRIPT" "iptables -I $rule # sing-box-script"
            done
            log_msg "$MESSAGE27"
            ip route add default dev $TUN_INTERFACE table $ROUTE_TABLE
            ip rule add to "$FAKEIP_SUBNET" lookup $ROUTE_TABLE priority 553
        elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
            log_msg "$MESSAGE27"
            ip route add local 0.0.0.0/0 dev lo table $ROUTE_TABLE
            ip rule add fwmark $TPROXY_MARK lookup $ROUTE_TABLE priority 553
        fi
        $SBS_MON &
    fi
    if [ -n "$WAN_PORTS" ]; then
        log_msg "$(printf "$MESSAGE28\n" "$WAN_PORTS")"
        for entry in $WAN_PORTS; do
            wan_port=$(echo "$entry" | cut -d ':' -f 2)
            if ! iptables-save | grep -q -- "-A INPUT -p tcp -m tcp --dport $wan_port -j ACCEPT"; then
                iptables -I INPUT -p tcp --dport "$wan_port" -j ACCEPT
            fi
            if ! iptables-save | grep -q -- "-A INPUT -p udp -m udp --dport $wan_port -j ACCEPT"; then
                iptables -I INPUT -p udp --dport "$wan_port" -j ACCEPT
            fi
            update_script "$FW_SCRIPT" "iptables -I INPUT -p tcp --dport "$wan_port" -j ACCEPT # sing-box-script
iptables -I INPUT -p udp --dport "$wan_port" -j ACCEPT # sing-box-script"
        done
    fi
    log_msg "$MESSAGE29"
    update_script "$SS_SCRIPT" "$SS_LINES # sing-box-script"
    log_msg "$MESSAGE30"
}

stop_sing_box() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi

    echo ""
    log_msg "$MESSAGE31"

    if [ -n "$TUN_INTERFACE" ]; then
        FW_RULES="FORWARD -i $TUN_INTERFACE -j ACCEPT
        FORWARD -o $TUN_INTERFACE -j ACCEPT
        INPUT -i $TUN_INTERFACE -j ACCEPT
        OUTPUT -o $TUN_INTERFACE -j ACCEPT"
    fi

    log_msg "$MESSAGE32"
    sed -i "/sing-box-script/d" "$SS_SCRIPT"
# Очистка скрипта firewall-start
    if [ -n "$WAN_PORTS" ] || [ -n "$TUN_INTERFACE" ]; then
        sed -i "/sing-box-script/d" "$FW_SCRIPT"
    fi
# Удаление правил iptables для открытых WAN портов
    if [ -n "$WAN_PORTS" ]; then
        log_msg "$(printf "$MESSAGE33\n" "$WAN_PORTS")"
        for entry in $WAN_PORTS; do
            wan_port=$(echo "$entry" | cut -d ':' -f 2)
            iptables -D INPUT -p udp --dport "$wan_port" -j ACCEPT
            iptables -D INPUT -p tcp --dport "$wan_port" -j ACCEPT
        done
    fi

    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; }; then
        pids=$(pidof "sbs-monitor")
        for pid in $pids; do
            kill "$pid" >/dev/null 2>&1
        done
# Удаление правил маршрутизации, маршрутов и правил файрвола
        log_msg "$MESSAGE34"
        ip rule del fwmark $TPROXY_MARK lookup $ROUTE_TABLE >/dev/null 2>&1
        ip rule del to "$FAKEIP_SUBNET" lookup $ROUTE_TABLE >/dev/null 2>&1
        for IP in $DEVICE_IPS; do
            ip rule del from $IP lookup $ROUTE_TABLE >/dev/null 2>&1
        done
        for IP in $EXC_DEVICE_IPS; do
            ip rule del from $IP lookup main >/dev/null 2>&1
        done
        for IP in ${FAKEIP_SUBNET:+$DEVICE_FIPS}; do
            ip rule del from $IP lookup main >/dev/null 2>&1
        done
        ip route flush table $ROUTE_TABLE
        if [ -n "$TUN_INTERFACE" ]; then
            log_msg "$MESSAGE35"
            echo "$FW_RULES" | while read -r rule; do
                manage_iptables "remove" "$rule" >/dev/null 2>&1
            done
        fi
# Удаление правил mangle
        if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ] && [ -n "$TPROXY_MARK" ]; then
            log_msg "$MESSAGE193"
            iptables -t mangle -D PREROUTING -j SBTPROXY  2>/dev/null
            iptables -t mangle -F SBTPROXY 2>/dev/null
            iptables -t mangle -X SBTPROXY  2>/dev/null
            if ipset list sbsexc-ipsetm >/dev/null 2>&1; then
                ipset destroy sbsexc-ipsetm >/dev/null 2>&1
            fi
            if ipset list sbsinc-ipsetm >/dev/null 2>&1; then
                ipset destroy sbsinc-ipsetm >/dev/null 2>&1
            fi
        fi
# Удаление правил nat и обновления скрипта nat-start
        log_msg "$MESSAGE36"
        if iptables -t nat -L SBS-TNAT >/dev/null 2>&1; then
            sed -i "/sing-box-script/d" "$NAT_SCRIPT"
            iptables -t nat -D PREROUTING -j SBS-TNAT
            iptables -t nat -F SBS-TNAT
            iptables -t nat -X SBS-TNAT
            if ipset list sbsexc-ipset >/dev/null 2>&1; then
                ipset destroy sbsexc-ipset >/dev/null 2>&1
            fi
            if ipset list sbsinc-ipset >/dev/null 2>&1; then
                ipset destroy sbsinc-ipset >/dev/null 2>&1
            fi
        fi
    fi
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -n "$FAKEIP_SUBNET" ] && [ -z "$DEVICE_IPS" ] && [ -z "$DEVICE_FIPS" ]; then
        pids=$(pidof "sbs-monitor")
        for pid in $pids; do
            kill "$pid" >/dev/null 2>&1
        done
        log_msg "$MESSAGE34"
        ip rule del fwmark $TPROXY_MARK lookup $ROUTE_TABLE >/dev/null 2>&1
        ip rule del to "$FAKEIP_SUBNET" lookup $ROUTE_TABLE >/dev/null 2>&1
        ip route flush table $ROUTE_TABLE
        if [ -n "$TUN_INTERFACE" ]; then
            log_msg "$MESSAGE35"
            echo "$FW_RULES" | while read -r rule; do
                manage_iptables "remove" "$rule" >/dev/null 2>&1
            done
        fi
        if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ] && [ -n "$TPROXY_MARK" ]; then
            log_msg "$MESSAGE193"
            iptables -t mangle -D PREROUTING -j SBTPROXY  2>/dev/null
            iptables -t mangle -F SBTPROXY 2>/dev/null
            iptables -t mangle -X SBTPROXY  2>/dev/null
        fi
    fi

    PIDS=$(pidof "sing-box")
    for pid in $PIDS; do
        kill "$pid"
    done

    log_msg "$MESSAGE37"
}

configure_interface() {
    source "$SBS_CONF"

    if [ -z "$DEVICE_IPS" ]; then
        echo ""
        echo "$MESSAGE38"
        while true; do
            read -p "$MESSAGE18" initial_choice
            case "$initial_choice" in
                0) echo "$MESSAGE39"; break ;;
                1) read -p "$MESSAGE40" new_ips
                   if [ -z "$new_ips" ]; then
                       echo "$MESSAGE41"
                   else
                       DEVICE_IPS="$new_ips"
                       sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"$new_ips\"|" "$SBS_CONF"
                       echo "$MESSAGE42"
                   fi; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        echo ""
        printf "$MESSAGE43\n" "$DEVICE_IPS"
        while true; do
            echo ""
            echo "$MESSAGE44"
            echo "$MESSAGE45"
            echo "$MESSAGE46"
            read -p "$MESSAGE47" action_choice
            case "$action_choice" in
                1) read -p "$MESSAGE48" ips_input
                   if [ -z "$ips_input" ]; then
                       echo "$MESSAGE49"
                   else
                       for ip in $ips_input; do
                           if echo "$DEVICE_IPS" | grep -q "$ip"; then
                               DEVICE_IPS=$(echo "$DEVICE_IPS" | tr ' ' '\n' | grep -v "^$ip$" | tr '\n' ' ' | xargs)
                               printf "$MESSAGE50\n" "$ip"
                           else
                               DEVICE_IPS="${DEVICE_IPS:+$DEVICE_IPS }$ip"
                               printf "$MESSAGE51\n" "$ip"
                           fi
                       done
                       sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"$DEVICE_IPS\"|" "$SBS_CONF"
                   fi; break ;;
                2) read -p "$MESSAGE52" new_ips
                   if [ -z "$new_ips" ]; then
                       DEVICE_IPS=""
                       sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"\"|" "$SBS_CONF"
                       echo "$MESSAGE53"
                   else
                       DEVICE_IPS="$new_ips"
                       sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"$new_ips\"|" "$SBS_CONF"
                       echo "$MESSAGE54"
                   fi; break ;;
                0) echo "$MESSAGE55"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi

    cidrs=""
    for ip in $DEVICE_IPS; do
        if echo "$ip" | grep -q '/'; then
            cidrs="$cidrs $ip"
        fi
    done
    if [ -n "$cidrs" ]; then
        if [ -z "$EXC_DEVICE_IPS" ]; then
            echo ""
            printf "$MESSAGE56\n" "$cidrs"
            echo "$MESSAGE57"
            while true; do
                read -p "$MESSAGE18" initial_exc_choice
                case "$initial_exc_choice" in
                    0) echo "$MESSAGE39"; break ;;
                    1) read -p "$MESSAGE40" exc_new_ips
                       if [ -z "$exc_new_ips" ]; then
                           echo "$MESSAGE58"
                       else
                           EXC_DEVICE_IPS="$exc_new_ips"
                           sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"$exc_new_ips\"|" "$SBS_CONF"
                           echo "$MESSAGE59"
                       fi; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        else
            echo ""
            printf "$MESSAGE56\n" "$cidrs"
            printf "$MESSAGE60\n" "$EXC_DEVICE_IPS"
            while true; do
            echo ""
            echo "$MESSAGE44"
            echo "$MESSAGE45"
            echo "$MESSAGE46"
            read -p "$MESSAGE47" action_exc_choice
                case "$action_exc_choice" in
                    1) read -p "$MESSAGE48" exc_ips_input
                       if [ -z "$exc_ips_input" ]; then
                           echo "$MESSAGE61"
                       else
                           for ip in $exc_ips_input; do
                               if echo "$EXC_DEVICE_IPS" | grep -q "$ip"; then
                                   EXC_DEVICE_IPS=$(echo "$EXC_DEVICE_IPS" | tr ' ' '\n' | grep -v "^$ip$" | tr '\n' ' ' | xargs)
                                   printf "$MESSAGE62\n" "$ip"
                               else
                                   EXC_DEVICE_IPS="${EXC_DEVICE_IPS:+$EXC_DEVICE_IPS }$ip"
                                   printf "$MESSAGE63\n" "$ip"
                               fi
                           done
                           sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"$EXC_DEVICE_IPS\"|" "$SBS_CONF"
                       fi; break ;;
                    2) read -p "$MESSAGE52" exc_new_ips
                       if [ -z "$exc_new_ips" ]; then
                           EXC_DEVICE_IPS=""
                           sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"\"|" "$SBS_CONF"
                           echo "$MESSAGE64"
                       else
                           EXC_DEVICE_IPS="$exc_new_ips"
                           sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"$exc_new_ips\"|" "$SBS_CONF"
                           echo "$MESSAGE65"
                       fi; break ;;
                    0) echo "$MESSAGE55"; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        fi
    else
        EXC_DEVICE_IPS=""
        sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"\"|" "$SBS_CONF"
    fi

    echo "$MESSAGE66"
}

configure_finterface() {
    source "$SBS_CONF"

    if [ -z "$DEVICE_FIPS" ]; then
        echo ""
        echo "$MESSAGE67"
        while true; do
            read -p "$MESSAGE18" initial_fchoice
            case "$initial_fchoice" in
                0) echo "$MESSAGE39"; break ;;
                1) read -p "$MESSAGE40" new_fips
                   if [ -z "$new_fips" ]; then
                       echo "$MESSAGE41"
                   else
                       DEVICE_FIPS="$new_fips"
                       sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"$new_fips\"|" "$SBS_CONF"
                       echo "$MESSAGE42"
                   fi; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        echo ""
        printf "$MESSAGE68\n" "$DEVICE_FIPS"
        while true; do
            echo ""
            echo "$MESSAGE44"
            echo "$MESSAGE45"
            echo "$MESSAGE46"
            read -p "$MESSAGE47" action_fchoice
            case "$action_fchoice" in
                1) read -p "$MESSAGE48" ips_finput
                   if [ -z "$ips_finput" ]; then
                       echo "$MESSAGE49"
                   else
                       for ip in $ips_finput; do
                           if echo "$DEVICE_FIPS" | grep -q "$ip"; then
                               DEVICE_FIPS=$(echo "$DEVICE_FIPS" | tr ' ' '\n' | grep -v "^$ip$" | tr '\n' ' ' | xargs)
                               printf "$MESSAGE69\n" "$ip"
                           else
                               DEVICE_FIPS="${DEVICE_FIPS:+$DEVICE_FIPS }$ip"
                               printf "$MESSAGE70\n" "$ip"
                           fi
                       done
                       sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"$DEVICE_FIPS\"|" "$SBS_CONF"
                   fi; break ;;
                2) read -p "$MESSAGE52" new_fips
                   if [ -z "$new_fips" ]; then
                       DEVICE_FIPS=""
                       sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"\"|" "$SBS_CONF"
                       echo "$MESSAGE71"
                   else
                       DEVICE_FIPS="$new_fips"
                       sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"$new_fips\"|" "$SBS_CONF"
                       echo "$MESSAGE72"
                   fi; break ;;
                0) echo "$MESSAGE55"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi

    fcidrs=""
    for ip in $DEVICE_FIPS; do
        if echo "$ip" | grep -q '/'; then
            fcidrs="$fcidrs $ip"
        fi
    done
    if [ -n "$fcidrs" ]; then
        if [ -z "$EXC_DEVICE_FIPS" ]; then
            echo ""
            printf "$MESSAGE73\n" "$fcidrs"
            echo "$MESSAGE74"
            while true; do
                read -p "$MESSAGE18" initial_exc_fchoice
                case "$initial_exc_fchoice" in
                    0) echo "$MESSAGE39"; break ;;
                    1) read -p "$MESSAGE40" exc_new_fips
                       if [ -z "$exc_new_fips" ]; then
                           echo "$MESSAGE75"
                       else
                           EXC_DEVICE_FIPS="$exc_new_fips"
                           sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"$exc_new_fips\"|" "$SBS_CONF"
                           echo "$MESSAGE76"
                       fi; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        else
            echo ""
            printf "$MESSAGE73\n" "$fcidrs"
            printf "$MESSAGE77\n" "$EXC_DEVICE_FIPS"
            while true; do
            echo ""
            echo "$MESSAGE44"
            echo "$MESSAGE45"
            echo "$MESSAGE46"
            read -p "$MESSAGE47" action_exc_fchoice
                case "$action_exc_fchoice" in
                    1) read -p "$MESSAGE48" exc_ips_finput
                       if [ -z "$exc_ips_finput" ]; then
                           echo "$MESSAGE78"
                       else
                           for ip in $exc_ips_finput; do
                               if echo "$EXC_DEVICE_FIPS" | grep -q "$ip"; then
                                   EXC_DEVICE_FIPS=$(echo "$EXC_DEVICE_FIPS" | tr ' ' '\n' | grep -v "^$ip$" | tr '\n' ' ' | xargs)
                                   printf "$MESSAGE79\n" "$ip"
                               else
                                   EXC_DEVICE_FIPS="${EXC_DEVICE_FIPS:+$EXC_DEVICE_FIPS }$ip"
                                   printf "$MESSAGE80\n" "$ip"
                               fi
                           done
                           sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"$EXC_DEVICE_FIPS\"|" "$SBS_CONF"
                       fi; break ;;
                    2) read -p "$MESSAGE52" exc_new_fips
                       if [ -z "$exc_new_fips" ]; then
                           EXC_DEVICE_FIPS=""
                           sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"\"|" "$SBS_CONF"
                           echo "$MESSAGE81"
                       else
                           EXC_DEVICE_FIPS="$exc_new_fips"
                           sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"$exc_new_fips\"|" "$SBS_CONF"
                           echo "$MESSAGE82"
                       fi; break ;;
                    0) echo "$MESSAGE55"; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        fi
    else
        EXC_DEVICE_FIPS=""
        sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"\"|" "$SBS_CONF"
    fi

    echo "$MESSAGE66"
}

configure_table() {
    source "$SBS_CONF"

    echo ""
    printf "$MESSAGE83\n" "$ROUTE_TABLE"
    echo "$MESSAGE84"
    while true; do
        read -p "$MESSAGE18" choice
        case "$choice" in
            0) echo "$MESSAGE85"; break ;;
            1) read -p "$MESSAGE86" new_table
               ROUTE_TABLE="$new_table"
               sed -i "s|^ROUTE_TABLE=\".*\"$|ROUTE_TABLE=\"$new_table\"|" "$SBS_CONF"
               log_msg "$(printf "$MESSAGE87\n" "$ROUTE_TABLE")"; break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
    echo "$MESSAGE66"
}

configure_tpmark() {
    source "$SBS_CONF"

    echo ""
    printf "$MESSAGE197\n" "$TPROXY_MARK"
    while true; do
        read -p "$MESSAGE18" choice
        case "$choice" in
            0) echo "$MESSAGE199"; break ;;
            1) read -p "$MESSAGE198" new_tpmark
               TPROXY_MARK="$new_tpmark"
               sed -i "s|^TPROXY_MARK=\".*\"$|TPROXY_MARK=\"$new_tpmark\"|" "$SBS_CONF"
               log_msg "$(printf "$MESSAGE147\n" "$TPROXY_MARK")"; break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
    echo "$MESSAGE66"
}

setup_sing_box() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi

    if is_running; then
        echo ""
        echo "$MESSAGE89"
        while true; do
            read -p "$MESSAGE18" choice
            case "$choice" in
                0) echo "$MESSAGE90"; exit 0 ;;
                1) stop_sing_box; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi

    echo "$MESSAGE200"
    update_tun_interface
    extract_listen_port TPROXY_PORT tproxy
    fakeip_check
    source "$SBS_CONF"

    if [ -z "$TUN_INTERFACE" ] && [ -z "$TPROXY_PORT" ]; then
        echo ""
        echo "$MESSAGE88"
        exit 0
    fi
    if [ -z "$FAKEIP_SUBNET" ]; then
        while true; do
            echo "$MESSAGE91"
            echo ""
            echo "$MESSAGE92"
            echo "$MESSAGE93"
            echo "2. $MESSAGE94"
            echo "0. $MESSAGE95"
            read -p "$MESSAGE99 [0-2]: " if_choice
            case "$if_choice" in
                1) configure_interface; source "$SBS_CONF" ;;
                2) if ! setup_pro; then continue; fi ;;
                0) break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        while true; do
            echo ""
            echo "$MESSAGE91"
            echo ""
            echo "$MESSAGE96"
            echo "$MESSAGE93"
            echo "$MESSAGE97"
            echo "3. $MESSAGE94"
            echo "0. $MESSAGE95"
            read -p "$MESSAGE99 [0-3]: " if_choice
            case "$if_choice" in
                1) configure_interface; source "$SBS_CONF" ;;
                2) configure_finterface; source "$SBS_CONF" ;;
                3) if ! setup_pro; then continue; fi ;;
                0) break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
    sing_box_start
}

setup_pro() {
    if [ -n "$TUN_INTERFACE" ]; then
        while true; do
            echo ""
            echo "$MESSAGE194"
            echo ""
            echo "$MESSAGE98"
            echo "$MESSAGE196"
            read -p "$MESSAGE99 [0-1]: " if_choice
            case "$if_choice" in
                1) configure_table; source "$SBS_CONF" ;;
                0) return 1 ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
        while true; do
            echo ""
            echo "$MESSAGE194"
            echo ""
            echo "$MESSAGE98"
            echo "$MESSAGE195"
            echo "$MESSAGE196"
            read -p "$MESSAGE99 [0-2]: " if_choice
            case "$if_choice" in
                1) configure_table; source "$SBS_CONF" ;;
                2) configure_tpmark; source "$SBS_CONF" ;;
                0) return 1 ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
}

download_updates() {
    source "$SBS_CONF"
    if [ "$SB_REPO" = "customa" ] && [ -z "$CUSTOM_REPO_A" ]; then
        sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF"
        SB_REPO="original"
    elif [ "$SB_REPO" = "customb" ] && [ -z "$CUSTOM_REPO_B" ]; then
        sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF"
        SB_REPO="original"
    fi
    UPD_SB_URL=$SB_URL
    if [ "$SB_REPO" = "customa" ]; then
        UPD_SB_URL=$(echo "$SB_URL" | sed "s|SagerNet/sing-box|$CUSTOM_REPO_A|")
    elif [ "$SB_REPO" = "customb" ]; then
        UPD_SB_URL=$(echo "$SB_URL" | sed "s|SagerNet/sing-box|$CUSTOM_REPO_B|")
    fi
    echo ""
    echo "$MESSAGE100"
    rm -rf "$SB_DOWNLOAD_DIR" "$SCRIPT_PATH"-tmp
    wget -q -O "$SCRIPT_PATH"-tmp "$SCRIPT_URL"
    silent_create_dir "$SB_DOWNLOAD_DIR"
    if [ "$(uname -m)" = "aarch64" ]; then
        SB_DOWNLOAD64_URL=$(wget --quiet --header="Accept: application/vnd.github.v3+json" -O - "$UPD_SB_URL" | grep -o '"browser_download_url":\s*"[^"]*linux-arm64.tar.gz"' | grep -o 'https://.*linux-arm64.tar.gz')
        DOWNLOAD_URL="$SB_DOWNLOAD64_URL"
        ARCHIVE_PATH="$SB_ARCHIVE64_PATH"
    else
        SB_DOWNLOAD_URL=$(wget --quiet --header="Accept: application/vnd.github.v3+json" -O - "$UPD_SB_URL" | grep -o '"browser_download_url":\s*"[^"]*linux-armv7.tar.gz"' | grep -o 'https://.*linux-armv7.tar.gz')
        DOWNLOAD_URL="$SB_DOWNLOAD_URL"
        ARCHIVE_PATH="$SB_ARCHIVE_PATH"
    fi
    if wget --spider -q "$DOWNLOAD_URL"; then
        wget -q -O "$ARCHIVE_PATH" "$DOWNLOAD_URL"
        tar -xzvf "$ARCHIVE_PATH" -C "$SB_DOWNLOAD_DIR" > /dev/null
        echo "$MESSAGE101"
    else
        echo "$MESSAGE219"
    fi
}

update_sing_box() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi
    download_updates
    update_sing_box_menu
}

update_sing_box_menu() {
    while true; do
        case "$SB_REPO" in
          original) additionally="$MESSAGE207" ;;
          customa) additionally="$MESSAGE213 A: $CUSTOM_REPO_A" ;;
          customb) additionally="$MESSAGE213 B: $CUSTOM_REPO_B" ;;
        esac
        [ -f "$ARCHIVE_PATH" ] && singbox_file=$(find "$SB_DOWNLOAD_DIR" -name "sing-box" -exec test -f {} \; -print) && [ -n "$singbox_file" ] && chmod 775 "$singbox_file"
        sbs_vers=$(get_sbs_version $SCRIPT_PATH)
        if [ -f "$SB_PATH" ]; then
            sb_vers=$(get_sb_version "$SB_PATH")
        else
            sb_vers=""
        fi
        sbs_vers_new=$(get_sbs_version "$SCRIPT_PATH"-tmp)
        if [ -f "$singbox_file" ]; then
            sb_vers_new=$(get_sb_version $singbox_file)
        else
            sb_vers_new=""
        fi
        echo ""
        echo "$MESSAGE102"
        echo ""
        is_running && echo "$MESSAGE103"
        printf "$MESSAGE104\n" "$sbs_vers" "$sbs_vers_new"
        printf "$MESSAGE105\n" "${sb_vers:-$MESSAGE169}" "${sb_vers_new:-$MESSAGE169.}"
        printf "$MESSAGE202\n" "$additionally"
        echo "0. $MESSAGE95"
        read -p "$MESSAGE99 [0-3]: " choice
        case "$choice" in
            1) is_running && stop_sing_box; update_sbs; break ;;
            2) [ -n "$sb_vers_new" ] && { is_running && stop_sing_box; updcore_sing_box; source "$SBS_CONF"; download_updates; continue; } || echo "$MESSAGE219" ;;
            3) change_sing_box_repo; source "$SBS_CONF"; download_updates; continue ;;
            0) rm -rf "$SB_DOWNLOAD_DIR" "$SCRIPT_PATH"-tmp; echo "$MESSAGE106"; is_running || sing_box_start; exit 0 ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

change_sing_box_repo() {
    while true; do
        echo ""
        echo "$MESSAGE203"
        echo "1. $MESSAGE204"
        if [ -n "$CUSTOM_REPO_A" ]; then
            printf "2. $MESSAGE205\n" "A: $CUSTOM_REPO_A"
        else
            printf "2. $MESSAGE205\n" "A: $MESSAGE215"
        fi
        if [ -n "$CUSTOM_REPO_B" ]; then
            printf "3. $MESSAGE205\n" "B: $CUSTOM_REPO_B"
        else
            printf "3. $MESSAGE205\n" "B: $MESSAGE215"
        fi
        echo "$MESSAGE209"
        echo "0. $MESSAGE206"
        read -p "$MESSAGE99 [0-4]: " choice_repo
        case "$choice_repo" in
            1) sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF"; echo "$MESSAGE207" ;;
            2) if [ -n "$CUSTOM_REPO_A" ]; then
                   sed -i 's|^SB_REPO="[^"]*"|SB_REPO="customa"|' "$SBS_CONF"; printf "$MESSAGE208\n" "A: $CUSTOM_REPO_A"
               else
                   printf "$MESSAGE216\n" "A"
               fi ;;
            3) if [ -n "$CUSTOM_REPO_B" ]; then
                   sed -i 's|^SB_REPO="[^"]*"|SB_REPO="customb"|' "$SBS_CONF"; printf "$MESSAGE208\n" "B: $CUSTOM_REPO_B"
               else
                   printf "$MESSAGE216\n" "B"
               fi ;;
            4) change_custom_repos; source "$SBS_CONF"; continue ;;
            0) return ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

change_custom_repos() {
    echo ""
    echo "$MESSAGE210"
    while true; do
        source "$SBS_CONF"
        echo ""
        echo "1. $MESSAGE211 A."
        if [ -n "$CUSTOM_REPO_A" ]; then
            printf "   $MESSAGE214\n" ": $CUSTOM_REPO_A"
        fi
        echo "2. $MESSAGE211 B."
        if [ -n "$CUSTOM_REPO_B" ]; then
            printf "   $MESSAGE214\n" ": $CUSTOM_REPO_B"
        fi
        echo "0. $MESSAGE218"
        read -p "$MESSAGE99 [0-2]: " repo_choice
        case "$repo_choice" in
            1) read -p "$MESSAGE212 A: " newrepoa
               if [ -z "$newrepoa" ]; then
                   sed -i 's|^CUSTOM_REPO_A="[^"]*"|CUSTOM_REPO_A=""|' "$SBS_CONF"
               elif echo "$newrepoa" | grep -Eqv '^[^[:space:]/]+/[^[:space:]/]+$'; then
                   echo "$MESSAGE217"
               else
                   sed -i "s|^CUSTOM_REPO_A=\"[^\"]*\"|CUSTOM_REPO_A=\"$newrepoa\"|" "$SBS_CONF"
               fi ;;
            2) read -p "$MESSAGE212 B: " newrepob
               if [ -z "$newrepob" ]; then
                   sed -i 's|^CUSTOM_REPO_B="[^"]*"|CUSTOM_REPO_B=""|' "$SBS_CONF"
               elif echo "$newrepob" | grep -Eqv '^[^[:space:]/]+/[^[:space:]/]+$'; then
                   echo "$MESSAGE217"
               else
                   sed -i "s|^CUSTOM_REPO_B=\"[^\"]*\"|CUSTOM_REPO_B=\"$newrepob\"|" "$SBS_CONF"
               fi ;;
            0) return ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

update_sbs() {
    echo ""
    echo "$MESSAGE107"
    cp "$SCRIPT_PATH"-tmp $SCRIPT_PATH
    chmod 775 $SCRIPT_PATH
    [ -f "$LANG_EN" ] && { wget -q -O $LANG_EN $LANG_EN_URL && chmod 664 $LANG_EN; }
    [ -f "$LANG_RU" ] && { wget -q -O $LANG_RU $LANG_RU_URL && chmod 664 $LANG_RU; }

    cat << EOF > $TEMP_UPDATE
#!/bin/sh
rm -f $TEMP_UPDATE
exec $SCRIPT_PATH updmonandconf
EOF
    chmod 775 $TEMP_UPDATE

    exec $TEMP_UPDATE
}

updmonandconf_sing_box() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi

    # Выполняем слияние новой версии sbs-conf со старой, не теряя значений переменных из старой.
    create_sbs_conf "$SBS_CONF"-tmp
    existing_vars=$(grep '^[A-Za-z0-9_]\+=' "$SBS_CONF")
    sed -i '/^#/d' "$SBS_CONF"
    comments=$(grep '^#' "$SBS_CONF"-tmp)
    vars_in_tmp=$(grep '^[A-Za-z0-9_]\+=' "$SBS_CONF"-tmp)
    echo "$comments" > "$SBS_CONF"
    echo "" >> "$SBS_CONF"
    echo "$existing_vars" >> "$SBS_CONF"
    for var in $vars_in_tmp; do
        var_name=$(echo "$var" | cut -d= -f1)
        if ! grep -q "^$var_name=" "$SBS_CONF"; then
            echo "$var" >> "$SBS_CONF"
        fi
    done
    rm -f "$SBS_CONF"-tmp

    create_sbs_monitor "$SBS_MON"
    echo "$MESSAGE108"
    exec $SCRIPT_PATH update
}

updcore_sing_box() {
    echo ""
    echo "$MESSAGE109"
    cp "$singbox_file" "$SB_DIR"; echo "$MESSAGE110"
    return
}

check_sing_box() {
    while true; do
        echo ""; echo "$MESSAGE111"
        if ! output=$($SB_PATH check -c $SB_CONFIG 2>&1); then
            echo "$MESSAGE112"
            echo "$output"
            echo ""
            echo "$MESSAGE113"
            is_running && echo "$MESSAGE114"
            while true; do
                read -p "$MESSAGE18" choice
                case "$choice" in
                    0) echo "$MESSAGE115"; break 2 ;;
                    1) echo ""; is_running && stop_sing_box; echo "$MESSAGE116"; nano $SB_CONFIG; echo "$MESSAGE117"; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        else
            echo "$MESSAGE118"; break
        fi
    done
}

format_sing_box() {
    if ! output=$($SB_PATH format -c $SB_CONFIG 2>&1); then
        echo ""; echo "$MESSAGE112"
        echo "$output"
        echo "$MESSAGE119"
        echo "$MESSAGE66"
    else
        echo ""; echo "$MESSAGE120"
        echo "$output"
        while true; do
            echo "$MESSAGE121"
            read -p "$MESSAGE18" save_choice
            case "$save_choice" in
                0) echo "$MESSAGE122"; break ;;
                1) $SB_PATH format -w -c $SB_CONFIG; echo "$MESSAGE123"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
}

config_sing_box() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi
    while true; do
        echo ""
        echo "$MESSAGE124"
        echo ""
        is_running && echo "$MESSAGE125" 
        echo "$MESSAGE126"
        echo "$MESSAGE127"
        echo "$MESSAGE128"
        echo "0-$MESSAGE95"
        read -p "$MESSAGE99 [0-3]: " choice
        case "$choice" in
            1) is_running && stop_sing_box; echo ""; echo "$MESSAGE116"; nano $SB_CONFIG; echo "$MESSAGE129" ;;
            2) check_sing_box ;;
            3) format_sing_box ;;
            0) break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
    is_running || sing_box_start
}

status_sing_box() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi

    if is_running; then
        echo "$MESSAGE30"
    else
        echo "$MESSAGE37"
    fi

    sbs_version=$(get_sbs_version $SCRIPT_PATH)
    if [ -n "$sbs_version" ]; then
        printf "$MESSAGE130\n" "$sbs_version"
    else
        echo "$MESSAGE131"
    fi

    sb_versplat=$(get_sb_versplat $SB_PATH)
    if [ -n "$sb_versplat" ]; then
        printf "$MESSAGE132\n" "$sb_versplat"
    else
        echo "$MESSAGE133"
    fi

    echo "$MESSAGE134"
    echo "$MESSAGE135"
    is_running && [ -n "$WAN_PORTS" ] && printf "$MESSAGE189\n" "$WAN_PORTS"
}

check_wan_ports() {
    current_ports=$(echo "$WAN_PORTS" | tr ' ' '\n')
    updated_ports=""
    for combination in $current_ports; do
        proxy_type=$(echo "$combination" | cut -d':' -f1)
        port=$(echo "$combination" | cut -d':' -f2)
        found_match=0
        in_inbounds=0
        search_port=0
        while read -r line; do
            if echo "$line" | grep -q '^[[:space:]]*"inbounds"'; then
                in_inbounds=1
            fi
            if [ "$in_inbounds" -eq 1 ] && echo "$line" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"$proxy_type\""; then
                search_port=1
                continue
            fi
            if [ "$search_port" = "1" ] && echo "$line" | grep -q "^[[:space:]]*\"listen_port\"[[:space:]]*:[[:space:]]*$port\\b"; then
                found_match=1
                break
            fi
            if echo "$line" | grep -q '^[[:space:]]*"type"[[:space:]]*:[[:space:]]*'; then
                search_port=0
            fi
        done < "$SB_CONFIG"
        if [ "$found_match" -eq 1 ]; then
            updated_ports="$updated_ports $combination"
        fi
    done
    updated_ports=$(echo "$updated_ports" | tr -s ' ' | sed 's/^ //')
    sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"$updated_ports\"|" "$SBS_CONF"
}

add_del_ports() {
    source "$SBS_CONF"
    VALID_TYPES="vless vmess shadowsocks trojan naive hysteria shadowtls tuic hysteria2"
    read -p "$MESSAGE136" input_combinations
    if [ -z "$input_combinations" ]; then
        echo "$MESSAGE137"
    fi
    combinations=$(echo "$input_combinations" | tr ' ' '\n')
    current_ports=$(grep "^WAN_PORTS=" "$SBS_CONF" | cut -d '"' -f 2)
    for combination in $combinations; do
      found_match=0
      proxy_type=$(echo "$combination" | cut -d':' -f1)
      port=$(echo "$combination" | cut -d':' -f2)
      if ! echo "$VALID_TYPES" | grep -qw "$proxy_type"; then
        printf "$MESSAGE138\n" "$proxy_type"
        continue
      fi
      in_inbounds=0
      search_port=0
      while read -r line; do
        if echo "$line" | grep -q '^[[:space:]]*"inbounds"[[:space:]]*:'; then
          in_inbounds=1
        fi
        if [ "$in_inbounds" -eq 1 ] && echo "$line" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"$proxy_type\""; then
          search_port=1
          continue
        fi
        if [ "$search_port" = "1" ] && echo "$line" | grep -q "^[[:space:]]*\"listen_port\"[[:space:]]*:[[:space:]]*$port\\b"; then
          found_match=1
          break
        fi
        if echo "$line" | grep -q '^[[:space:]]*"type"[[:space:]]*:'; then
          search_port=0
        fi
      done < "$SB_CONFIG"
      if [ "$found_match" -eq 0 ]; then
        printf "$MESSAGE139\n" "$proxy_type:$port"
        continue
      fi
      if echo "$current_ports" | grep -wq "$proxy_type:$port"; then
        current_ports=$(echo "$current_ports" | sed "s/\b$proxy_type:$port\b//g" | tr -s ' ' | sed 's/^ //')
        printf "$MESSAGE140\n" "$proxy_type:$port"
      else
        if [ -n "$current_ports" ]; then
          current_ports="$current_ports $proxy_type:$port"
        else
          current_ports="$proxy_type:$port"
        fi
        printf "$MESSAGE141\n" "$proxy_type:$port"
      fi
    done
    sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"$current_ports\"|" "$SBS_CONF"
    source "$SBS_CONF"
    echo ""
    if [ -z "$WAN_PORTS" ]; then
        echo "$MESSAGE142"
    else
        printf "$MESSAGE143\n" "$WAN_PORTS"
    fi
    serv_sing_box
}

exch_ports() {
    source "$SBS_CONF"
    VALID_TYPES="vless vmess shadowsocks trojan naive hysteria shadowtls tuic hysteria2"
    read -p "$MESSAGE136" input_combinations
    if [ -z "$input_combinations" ];then
        echo "$MESSAGE137"
        sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"\"|" "$SBS_CONF"
        source "$SBS_CONF"
        echo ""
        echo "$MESSAGE144"
        serv_sing_box
        return
    fi
    combinations=$(echo "$input_combinations" | tr ' ' '\n')
    new_ports=""
    invalid_combinations=0
    for combination in $combinations; do
        found_match=0
        proxy_type=$(echo "$combination" | cut -d':' -f1)
        port=$(echo "$combination" | cut -d':' -f2)
        if ! echo "$VALID_TYPES" | grep -qw "$proxy_type"; then
            printf "$MESSAGE138\n" "$proxy_type"
            invalid_combinations=1
            continue
        fi
        in_inbounds=0
        search_port=0
        while read -r line; do
            if echo "$line" | grep -q '^[[:space:]]*"inbounds"[[:space:]]*:'; then
                in_inbounds=1
            fi
            if [ "$in_inbounds" -eq 1 ] && echo "$line" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"$proxy_type\""; then
                search_port=1
                continue
            fi
            if [ "$search_port" = "1" ] && echo "$line" | grep -q "^[[:space:]]*\"listen_port\"[[:space:]]*:[[:space:]]*$port\\b"; then
                found_match=1
                break
            fi
            if echo "$line" | grep -q '^[[:space:]]*"type"[[:space:]]*:'; then
                search_port=0
            fi
        done < "$SB_CONFIG"
        if [ "$found_match" -eq 0 ]; then
            printf "$MESSAGE139\n" "$proxy_type:$port"
            invalid_combinations=1
            continue
        fi
        if [ -n "$new_ports" ]; then
            new_ports="$new_ports $proxy_type:$port"
        else
            new_ports="$proxy_type:$port"
        fi
    done
    if [ -n "$new_ports" ]; then
        sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"$new_ports\"|" "$SBS_CONF"
        source "$SBS_CONF"
        echo ""
        printf "$MESSAGE145\n" "$WAN_PORTS"
    else
        echo "$MESSAGE146"
        echo ""
        printf "$MESSAGE143\n" "$WAN_PORTS"
    fi
    serv_sing_box
}

server_sing_box() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi
    if is_running; then
        echo ""
        echo "$MESSAGE148"
        while true; do
            read -p "$MESSAGE18" choice
            case "$choice" in
                0) echo "$MESSAGE90"; exit 0 ;;
                1) stop_sing_box; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
    echo ""
    echo "$MESSAGE149"
    echo ""
    echo "$MESSAGE150"
    echo "$MESSAGE151"
    echo "$MESSAGE152"
    echo ""
    check_wan_ports
    source "$SBS_CONF"
    if [ -z "$WAN_PORTS" ]; then
        echo "$MESSAGE142"
    else
        printf "$MESSAGE143\n" "$WAN_PORTS"
    fi
    serv_sing_box
}

serv_sing_box() {
    source "$SBS_CONF"
    check_wan_ports
    source "$SBS_CONF"
    if [ -z "$WAN_PORTS" ]; then
        while true; do
            echo "$MESSAGE153"
            read -p "$MESSAGE18" init_portchoice
            case "$init_portchoice" in
                0) echo "$MESSAGE154"; break ;;
                1) add_del_ports; exit 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        while true; do
            echo "$MESSAGE155"
            echo "$MESSAGE156"
            echo "0. $MESSAGE95"
            read -p "$MESSAGE47" act_portchoice
            case "$act_portchoice" in
                1) add_del_ports; exit 0 ;;
                2) exch_ports; exit 0 ;;
                0) echo "$MESSAGE95"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
    sing_box_start
}

install_sing_box() {
    handle_existing_file "$TEMP_SBS_CONF" create_sbs_conf
    echo "Выбор языка / Select language:"
    while true; do
        echo " 1 - Русский / Russian"
        echo " 2 - Aнглийский / English"
        echo " 0 - Выход / Exit"
        read -p "Введите номер пункта / Enter item number: " language_choice
        case "$language_choice" in
            1) wget -q -O $TEMP_LANG_RU $LANG_RU_URL && chmod 664 $TEMP_LANG_RU; source "$TEMP_LANG_RU"; sed -i 's/^LANG=".*"/LANG="ru"/' "$TEMP_SBS_CONF"; break ;;
            2) wget -q -O $TEMP_LANG_EN $LANG_EN_URL && chmod 664 $TEMP_LANG_EN; source "$TEMP_LANG_EN"; sed -i 's/^LANG=".*"/LANG="en"/' "$TEMP_SBS_CONF"; break ;;
            0) delete_if_not_current_dir; rm -f "$TEMP_SBS_CONF"; exit 0 ;;
            *) echo "Некорректный ввод. Попробуйте ещё раз. / Invalid input. Please try again." ;;
        esac
    done

    source "$TEMP_SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$TEMP_LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$TEMP_LANG_EN"
    fi

    echo "$MESSAGE158"
    while true; do
        read -p "$MESSAGE18" choice
        case $choice in
            0) delete_if_not_current_dir; rm -f $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN; echo "$MESSAGE159"; exit 0 ;;
            1) if is_running; then
                echo "$MESSAGE160"
                while true; do
                   read -p "$MESSAGE18" continue_choice
                   case "$continue_choice" in
                       0) delete_if_not_current_dir; rm -f $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN; echo "$MESSAGE159"; exit 0 ;;
                       1) stop_sing_box; break ;;
                       *) echo "$MESSAGE6" ;;
                   esac
                done
               else break; fi; break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done

    echo "$MESSAGE161"
    create_or_use_existing "$JFFS_SB_DIR"
    handle_existing_file "$SCRIPT_PATH" self_copy
    ln -sf $SCRIPT_PATH $LN_PATH
    handle_existing_file "$SBS_MON" create_sbs_monitor
    check_file_existence_and_download "$SB_CONFIG" "$SB_CONFIG_URL"
    chmod 664 "$SB_CONFIG"
    check_copy_file "$TEMP_SBS_CONF" "$SBS_CONF"
    check_copy_file "$TEMP_LANG_RU" "$LANG_RU"
    check_copy_file "$TEMP_LANG_EN" "$LANG_EN"

    if [ -n "$ROOT_DIR" ]; then
        create_or_use_existing "$SB_DIR"
    else
        printf "$MESSAGE162\n" "$ROOT_DIR"
        delete_if_not_current_dir; rm -f $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN
        exit 1
    fi

    create_dir "$SB_DOWNLOAD_DIR"
    if [ "$(uname -m)" = "aarch64" ]; then
        SB_DOWNLOAD64_URL=$(wget --quiet --header="Accept: application/vnd.github.v3+json" -O - "$SB_URL" | grep -o '"browser_download_url":\s*"[^"]*linux-arm64.tar.gz"' | grep -o 'https://.*linux-arm64.tar.gz')
        DOWNLOAD_URL="$SB_DOWNLOAD64_URL"
        ARCHIVE_PATH="$SB_ARCHIVE64_PATH"
    else
        SB_DOWNLOAD_URL=$(wget --quiet --header="Accept: application/vnd.github.v3+json" -O - "$SB_URL" | grep -o '"browser_download_url":\s*"[^"]*linux-armv7.tar.gz"' | grep -o 'https://.*linux-armv7.tar.gz')
        DOWNLOAD_URL="$SB_DOWNLOAD_URL"
        ARCHIVE_PATH="$SB_ARCHIVE_PATH"
    fi
    echo "$MESSAGE163"

    if wget --spider -q "$DOWNLOAD_URL"; then
        wget -q -O "$ARCHIVE_PATH" "$DOWNLOAD_URL"
        echo "$MESSAGE164"
        tar -xzvf "$ARCHIVE_PATH" -C "$SB_DOWNLOAD_DIR"
        sing_box_file=$(find "$SB_DOWNLOAD_DIR" -name "sing-box" -exec test -f {} \; -print)
        if [ -f "$SB_PATH" ]; then
            echo "$MESSAGE165"
            while true; do
                read -p "$MESSAGE12" choice
                case $choice in
                    0) echo "$MESSAGE13"; break ;;
                    1) cp "$sing_box_file" "$SB_DIR"; chmod 775 "$SB_PATH"; printf "$MESSAGE166\n" "$SB_PATH"; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        else
            cp "$sing_box_file" "$SB_DIR"; printf "$MESSAGE168\n" "$SB_DIR"
        fi
    else
        if [ -f "$SB_PATH" ]; then
            echo "$MESSAGE167 $MESSAGE13"
        else
            echo "$MESSAGE167 $MESSAGE220"
            echo "$MESSAGE159"
            delete_if_not_current_dir; rm -rf $SB_DIR $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN $JFFS_SB_DIR $LN_PATH; exit 1
        fi
    fi
    delete_if_not_current_dir; rm -rf $SB_DOWNLOAD_DIR $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN
    printf "$MESSAGE170\n" "$SB_DOWNLOAD_DIR"
    echo ""
    echo "$MESSAGE171"
}

remove_sing_box() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi

    echo "$MESSAGE172"
    while true; do
        read -p "$MESSAGE18" choice
        case $choice in
            0) echo "$MESSAGE173"; exit 0 ;;
            1) is_running && stop_sing_box; echo "$MESSAGE174"; rm -rf $SB_DIR $JFFS_SB_DIR $LN_PATH; echo "$MESSAGE175"; exit 0 ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

show_menu() {
    source "$SBS_CONF"
    if [ "$LANG" = "ru" ]; then
        source "$LANG_RU"
    elif [ "$LANG" = "en" ]; then
        source "$LANG_EN"
    fi

    echo "$MESSAGE176"
    echo "$MESSAGE177"
    echo "$MESSAGE178"
    echo "$MESSAGE179"
    echo "$MESSAGE180"
    echo "$MESSAGE181"
    echo "$MESSAGE182"
    echo "$MESSAGE183"
    echo "$MESSAGE184"
    echo "$MESSAGE185"
    echo "$MESSAGE157"
    echo "$MESSAGE186"
    echo "0) $MESSAGE95"
}

case "$1" in
    install) install_sing_box ;;
    start) start_sing_box ;;
    stop) stop_sing_box ;;
    restart) stop_sing_box; sleep 3; start_sing_box ;;
    config) config_sing_box ;;
    setup) setup_sing_box ;;
    update) update_sing_box ;;
    status) status_sing_box ;;
    server) server_sing_box ;;
    lang) change_language ;;
    remove) remove_sing_box ;;
    updmonandconf) updmonandconf_sing_box ;;
    *)
    while true; do
        show_menu
        read -p "$MESSAGE187" choice
        case $choice in
            1) start_sing_box; break ;;
            2) stop_sing_box; break ;;
            3) stop_sing_box; sleep 3; start_sing_box; break ;;
            4) config_sing_box; break ;;
            5) setup_sing_box; break ;;
            6) update_sing_box; break ;;
            7) status_sing_box; break ;;
            8) server_sing_box; break ;;
            9) change_language; break ;;
            10) remove_sing_box; break ;;
            0) exit 0 ;;
            *) echo "$MESSAGE6" ;;
        esac
    done ;;
esac

# The developer of script is Dr4tez dr4tez@gmail.com https://github.com/Dr4tez/sing-box4asus
# The sing-box core is used for work https://github.com/SagerNet/sing-box
