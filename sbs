#!/bin/sh

# Version 2.3
# Скрипт для запуска sing-box на роутерах Asus с прошивкой Мерлина и установленным на USB носителе Entware.

# Переменные
JFFS_SB_DIR="/jffs/addons/sing-box-script"
SB_CONFIG="$JFFS_SB_DIR/config.json"
SCRIPT_PATH="$JFFS_SB_DIR/sbs"
SBS_CONF="$JFFS_SB_DIR/sbs-conf"
SBS_MON="$JFFS_SB_DIR/sbs-monitor"
LANG_RU="$JFFS_SB_DIR/sbs-lang-ru"
LANG_EN="$JFFS_SB_DIR/sbs-lang-en"
SCRIPT_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/sbs"
SB_CONFIG_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/config.json"
LANG_RU_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/sbs-lang-ru"
LANG_EN_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/sbs-lang-en"
ROOT_DIR="/opt/root"
SB_DIR="$ROOT_DIR/sing-box"
SB_PATH="$SB_DIR/sing-box"
SB_URL="https://api.github.com/repos/SagerNet/sing-box/releases"
SB_DOWNLOAD_DIR="$SB_DIR/sing-box-download"
TEMP_UPDATE="$SB_DOWNLOAD_DIR/temp-update"
TEMP_SCRIPT_PATH="$SB_DOWNLOAD_DIR/sbs"
TEMP_SBS_CONF="$SB_DOWNLOAD_DIR/sbs-conf"
TEMP_LANG_RU="$SB_DOWNLOAD_DIR/sbs-lang-ru"
TEMP_LANG_EN="$SB_DOWNLOAD_DIR/sbs-lang-en"
FW_SCRIPT="/jffs/scripts/firewall-start"
NAT_SCRIPT="/jffs/scripts/nat-start"
SS_SCRIPT="/jffs/scripts/services-start"
SS_LINES="(sleep 45 && $SCRIPT_PATH start) &"
LN_PATH="/opt/bin/sbs"

# Функции
log_msg() {
    echo "$1"
    logger -t "sbs" "$1"
}

create_dir() {
    mkdir -p "$1"
    chmod 775 "$1"
    printf "$MESSAGE1\n" "$1"
}

create_sbs_conf() {
    cat << EOF > "$1"
# Создан в SBS 2.3
# Этот файл создаётся автоматически и значения в него вводятся через консоль роутера при выполнении определённых пунктов в меню, вызываемых командами 'sbs setup', 'sbs update' или 'sbs server'. Не рекомендуется изменять значения в нём напрямую, в обход перечисленных команд.
# Если вы всё же хотите изменить здесь значения напрямую, то перед этим обязательно остановите sing-box с помощью команды 'sbs stop' в консоли роутера, иначе вам не избежать неприятных багов, от которых без специальных познаний будет сложно избавиться.
#
# Строка DEVICE_IPS - тут между кавычками указываются IP-адреса устройств, трафик которых вы хотите направить через sing-box. IP-адреса должны быть в одну строку и между ними должно быть только по одному пробелу. Так же тут можно указать и подсеть в формате CIDR, например 192.168.50.0/24. Значения задаются в первом пункте меню 'sbs setup'.
# Строка EXC_DEVICE_IPS - если в строке DEVICE_IPS указана подсеть, то тут можно указать IP-адреса устройств из этой подсети, трафик которых вы хотите исключить из направления через sing-box. Так же тут можно указать подсеть меньшего размера, которая входит в указанную в DEVICE_IPS, если это соответствует вашим целям. Значения задаются в первом пункте меню 'sbs setup'.
# Строка DEVICE_FIPS - тут указываются IP-адреса устройств, которые вы хотите заставить работать через fakeip. В остальном аналогично строке DEVICE_IPS. Значения задаются в меню 'sbs setup', только если в файле конфигурации config.json присутствуют настройки fakeip.
# Строка EXC_DEVICE_FIPS - если в строке DEVICE_FIPS указана подсеть, то тут можно указать IP-адреса устройств из этой подсети, которые вы хотите исключить из работы через fakeip. В остальном аналогично строке EXC_DEVICE_IPS. Значения задаются в меню 'sbs setup', только если в файле конфигурации config.json присутствуют настройки fakeip.
# Строка ROUTE_TABLE - если указанный в ней по умолчанию номер таблицы маршрутизации 5553 уже занят в вашем роутере, что маловероятно, можете заменить его на другой, который не занят. Значения задаются в меню 'sbs setup' в подменю продвинутых настроек.
# Строка FW_MARK - если указанный в ней по умолчанию fwmark 0x4d3c2b1a уже занят в вашем роутере, что маловероятно, можете заменить его на другой, который не занят. Значение задаётся в меню 'sbs setup' в подменю продвинутых настроек.
# Строка WAN_PORTS - при старте sing-box указанные в ней порты будут открыты для доступа из WAN в роутер. Не открывайте порты из интернета в свой роутер без осознанной необходимости. Открытие не тех портов может привести к потере всех данных в вашей домашней сети. Значения задаются в меню 'sbs server'.
# Строка LANG - если указать значение "ru", то все сообщения от скрипта будут на русском языке, а если "en"- на английском. Значения задаются в меню 'sbs lang'.
# Строка SB_REPO - тут указывается какой репозиторий использовать для загрузки ядра sing-box. Возможные значения "original", "customa" и "customb" соответствуют официальному и двум кастомным репозиториям. Значение задаётся при выборе одного из первых трёх пунктов в подменю 3-1 меню 'sbs update'.
# Строки CUSTOM_REPO_A и CUSTOM_REPO_B - в них указываются кастомные репозитории ядра sing-box в формате "имя_github_профиля/наименование_репозитория", например "Dr4tez/sing-box-mod". Значения задаются в первых двух пунктах подменю 3-1-4 меню 'sbs update'.
# Строка CORE_VERS - тут указывается какое ядро sing-box будет установлено. Значения "release", "pre_release" или "given" - соответствуют новейшему стабильному релизу, новейшему пре-релизу и заданной версии. Значение задаётся при выборе одного из первых трёх пунктов в подменю 3-2 меню 'sbs update'.
# Строка GIVEN_VERS - тут указывается какая конкретно версия ядра sing-box может быть установлена, если значение строки CORE_VERS будет "given". Значение задаётся в пункте 3-2-4 меню 'sbs update'. Например "1.11.14" или "1.12.0-beta.32".
# Строка NUM_RELEASES - тут указывается глубина поиска, т.е. количество последних релизов, среди которого будут искаться заданная версия ядра, новейший стабильный релиз или новейший пре-релиз ядра. Значение задаётся в пункте 3-2-5 меню 'sbs update'. Например "90".
# Строка DNS_PORT - тут указывается порт, на который в NAT PREROUTING будет заменяться порт назначения DNS запросов от устройств, работающих черех sing-box с tun inbound. Значение по умолчанию 53535. При необходимости можно изменить на любой 4-х или 5-значный, не занятый вашей системой, в пункте 2-3 меню 'sbs setup'.
# Строки TUN_INTERFACE, TPROXY_PORT и FAKEIP_SUBNET - их значения автоматически извлекаются из конфигурационного файла sing-box и записываются сюда.

DEVICE_IPS=""
EXC_DEVICE_IPS=""
DEVICE_FIPS=""
EXC_DEVICE_FIPS=""
ROUTE_TABLE="5553"
FW_MARK="0x4d3c2b1a"
WAN_PORTS=""
LANG=""
SB_REPO="original"
CUSTOM_REPO_A="Dr4tez/sing-box-mod"
CUSTOM_REPO_B=""
CORE_VERS="release"
GIVEN_VERS=""
NUM_RELEASES=""
DNS_PORT="53535"
TUN_INTERFACE=""
TPROXY_PORT=""
FAKEIP_SUBNET=""
EOF
    chmod 664 "$1"
}

create_sbs_monitor() {
    script_path="$1"
    script_content='#!/bin/sh
# Создан в SBS 2.3

source "/jffs/addons/sing-box-script/sbs-conf"

if [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; then
    m_sorted_subnets=$(echo "$DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS}" | tr " " "\n" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+" | sort -t "/" -k2,2n)
fi

m_update_script() {
    [ -f "$1" ] || { echo "#!/bin/sh" > "$1"; chmod 755 "$1"; }
    echo "$2" | while IFS= read -r line; do
        grep -qF "$line" "$1" || echo "$line" >> "$1"
    done
}

m_get_main_ips() {
    ip -4 route show | awk "{print \$1}" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/[0-9]+)?$" | while read addr; do
        case "$addr" in
            */*) echo "$addr" ;;
            *) echo "$addr/32" ;;
        esac
    done
}

sbs_monitor_rr() {
    route_in_process=0

  { ip monitor route | while read _; do
        if [ "$route_in_process" -eq 0 ]; then
            route_in_process=1
            if ! ps | grep "[s]ing-box.*run" >/dev/null 2>&1; then
                "/opt/root/sing-box/sing-box" run -c "/jffs/addons/sing-box-script/config.json" &
            fi
            if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; } && [ -n "$FW_MARK" ]; then
                sed -i "/sing-box-script-mangle/d" /jffs/scripts/nat-start
                iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null
                iptables -t mangle -F SBS-MANGLE 2>/dev/null
                iptables -t mangle -N SBS-MANGLE 2>/dev/null
                iptables -t mangle -I PREROUTING -j SBS-MANGLE
                m_update_script /jffs/scripts/nat-start "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBS-MANGLE # sing-box-script-mangle"
                if [ -n "$m_sorted_subnets" ]; then
                    echo "$m_sorted_subnets" | while read -r subnet; do
                        if echo "$DEVICE_IPS" | grep -qw "$subnet"; then
                            iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN # sing-box-script-mangle"
                            if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                                iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                                iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                            else
                                iptables -t mangle -I SBS-MANGLE -s $subnet -j MARK --set-mark $FW_MARK
                                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -s $subnet -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                            fi
                        elif echo "$EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS}" | grep -qw "$subnet"; then
                            iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN # sing-box-script-mangle"
                        fi
                    done
                fi
                if ipset list sbsinc-ipset >/dev/null 2>&1; then
                    iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j RETURN # sing-box-script-mangle"
                    if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                        iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                    else
                        iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j MARK --set-mark $FW_MARK
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                    fi
                fi
                if ipset list sbsfinc-ipset >/dev/null 2>&1; then
                    iptables -t mangle -I SBS-MANGLE -m set --match-set sbsfinc-ipset src -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsfinc-ipset src -j RETURN # sing-box-script-mangle"
                fi
                if [ -n "$FAKEIP_SUBNET" ]; then
                    iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j RETURN # sing-box-script-mangle"
                    if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                        iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                    else
                        iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                    fi
                fi
                m_get_main_ips | while read mainip; do
                    iptables -t mangle -I SBS-MANGLE -d $mainip -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -d $mainip -j RETURN # sing-box-script-mangle"
                done
                iptables -t mangle -I SBS-MANGLE -p udp --dport 67 -j RETURN
                iptables -t mangle -I SBS-MANGLE -p udp --dport 68 -j RETURN
                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p udp --dport 67 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp --dport 68 -j RETURN # sing-box-script-mangle"

                if [ -n "$m_sorted_subnets" ]; then
                    echo "$m_sorted_subnets" | while read -r subnet; do
                        if echo "$DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}" | grep -qw "$subnet"; then
                            iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN
                            iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle"
                            if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                                iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                                iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                            else
                                iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j MARK --set-mark $FW_MARK
                                iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j MARK --set-mark $FW_MARK
                                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                            fi
                        elif echo "$EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$EXC_DEVICE_FIPS}" | grep -qw "$subnet"; then
                            iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN
                            iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle"
                        fi
                    done
                fi
                for setname in sbsinc-ipset sbsfinc-ipset; do
                    if ipset list "$setname" >/dev/null 2>&1; then
                        iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src --dport 53 -j RETURN
                        iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src --dport 53 -j RETURN
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src --dport 53 -j RETURN # sing-box-script-mangle"
                        if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                            iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                            iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                        else
                            iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src --dport 53 -j MARK --set-mark $FW_MARK
                            iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src --dport 53 -j MARK --set-mark $FW_MARK
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                        fi
                    fi
                done
                if ipset list sbsexc-ipset >/dev/null 2>&1; then
                    iptables -t mangle -I SBS-MANGLE -m set --match-set sbsexc-ipset src -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsexc-ipset src -j RETURN # sing-box-script-mangle"
                fi
                m_update_script /jffs/scripts/nat-start ") & # sing-box-script-mangle"
            fi
            if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -z "$DEVICE_IPS" ] && [ -z "$DEVICE_FIPS" ] && [ -n "$FAKEIP_SUBNET" ] && [ -n "$FW_MARK" ]; then
                sed -i "/sing-box-script-mangle/d" /jffs/scripts/nat-start
                iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null
                iptables -t mangle -F SBS-MANGLE 2>/dev/null
                iptables -t mangle -N SBS-MANGLE 2>/dev/null
                iptables -t mangle -I PREROUTING -j SBS-MANGLE
                m_update_script /jffs/scripts/nat-start "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBS-MANGLE # sing-box-script-mangle"
                if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                    iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                    iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK; ) & # sing-box-script-mangle"
                else
                    iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK; ) & # sing-box-script-mangle"
                fi
            fi
            if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -n "$FW_MARK" ]; then
                if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                    if ! ip route show table "$ROUTE_TABLE" >/dev/null 2>&1; then
                        ip route add local 0.0.0.0/0 dev lo table $ROUTE_TABLE
                    fi
                else
                    if ! ip route show table "$ROUTE_TABLE" >/dev/null 2>&1; then
                        ip route add default dev $TUN_INTERFACE table $ROUTE_TABLE
                    fi
                    echo 2 > /proc/sys/net/ipv4/conf/$TUN_INTERFACE/rp_filter
                fi
            fi; route_in_process=0
        fi
    done } &

    ip monitor rule | while read line; do
        if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -n "$FW_MARK" ]; then
            if ! ip rule show | grep -q "from all fwmark ${FW_MARK%%/*} lookup $ROUTE_TABLE"; then
                ip rule add fwmark $FW_MARK lookup $ROUTE_TABLE priority 5353
            fi
        fi
    done
}

trap "" SIGHUP

if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
    (
        while true; do
            if ! ps | grep "[s]ing-box.*run" >/dev/null 2>&1; then
                "/opt/root/sing-box/sing-box" run -c "/jffs/addons/sing-box-script/config.json" &
            fi
            sleep 5
        done
    ) &
fi

sbs_monitor_rr 2>/dev/null
'
    echo "$script_content" > "$script_path"
    chmod +x "$script_path"
}

check_file_existence_and_download() {
    local file_path="$1"
    local file_url="$2"
    local file_name=$(basename "$file_path")

    if [ -f "$file_path" ]; then
        printf "$MESSAGE2\n" "$file_name"
        while true; do
            read -p "$MESSAGE3" choice
            case $choice in
                0) printf "$MESSAGE4\n" "$file_name"; return 0 ;;
                1) printf "$MESSAGE5\n" "$file_name"; wget -q -O "$file_path" "$file_url"; return 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        printf "$MESSAGE7\n" "$file_name"
        wget -q -O "$file_path" "$file_url"
    fi
}

del_if_notcurrent() {
    local current_path="$(readlink -f "$0")"
    [ "$current_path" != "$SCRIPT_PATH" ] && rm -f "$current_path"
}

create_or_use_existing() {
    local dir_path="$1"

    if [ -d "$dir_path" ]; then
        printf "$MESSAGE8\n" "$dir_path"
        while true; do
            read -p "$MESSAGE9" choice
            case $choice in
                0) del_if_notcurrent; rm -f $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN; echo "$MESSAGE10"; exit 0 ;;
                1) printf "$MESSAGE11\n" "$dir_path"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        create_dir "$dir_path"
    fi
}

handle_existing_file() {
    local file_path="$1"
    local create_function="$2"

    if [ -f "$file_path" ]; then
        printf "$MESSAGE2\n" "$file_path"
        while true; do
            read -p "$MESSAGE12" choice
            case $choice in
                0) echo "$MESSAGE13"; break ;;
                1) printf "$MESSAGE14\n" "$file_path"; "$create_function" "$file_path"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        "$create_function" "$file_path"
    fi
}

check_copy_file() {
    local src_file="$1"
    local dst_file="$2"

    if [ -f "$dst_file" ]; then
        printf "$MESSAGE2\n" "$dst_file"
        while true; do
            read -p "$MESSAGE12" choice
            case $choice in
                0) echo "$MESSAGE13"; break ;;
                1) [ -f "$src_file" ] && printf "$MESSAGE14\n" "$dst_file" && cp "$src_file" "$dst_file"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        [ -f "$src_file" ] && cp "$src_file" "$dst_file"
    fi
}

change_language() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    while true; do
        if [ "$LANG" = "ru" ]; then
            echo "Перейти на английский?"
            read -p "$MESSAGE18" choice
            case "$choice" in
                0) echo "$MESSAGE66"; break ;;
                1) [ -f "$LANG_EN" ] || { wget -q -O $LANG_EN $LANG_EN_URL && chmod 664 $LANG_EN; }; source "$LANG_EN"; sed -i 's/^LANG=".*"/LANG="en"/' "$SBS_CONF"; echo "$MESSAGE188"; exit 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        elif [ "$LANG" = "en" ]; then
            echo "Switch to Russian?"
            read -p "$MESSAGE18" choice
            case "$choice" in
                0) echo "$MESSAGE66"; break ;;
                1) [ -f "$LANG_RU" ] || { wget -q -O $LANG_RU $LANG_RU_URL && chmod 664 $LANG_RU; }; source "$LANG_RU"; sed -i 's/^LANG=".*"/LANG="ru"/' "$SBS_CONF"; echo "$MESSAGE188"; exit 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        fi
    done
}

update_script() {
    [ -f "$1" ] || { echo "#!/bin/sh" > "$1"; chmod 755 "$1"; }
    echo "$2" | while IFS= read -r line; do
        grep -qF "$line" "$1" || echo "$line" >> "$1"
    done
}

manage_iptables() {
    if [ "$1" = "add" ]; then
        iptables -C $2 2>/dev/null || iptables -I $2 || log_msg "$(printf "$MESSAGE15\n" "$2")"
    elif [ "$1" = "remove" ]; then
        iptables -C $2 2>/dev/null && iptables -D $2 || log_msg "$(printf "$MESSAGE16\n" "$2")"
    fi
}

is_running() {
    ps | grep -v grep | grep -q "$SB_PATH"
}

get_sbs_version() {
    sed -n '3s/^# Version //p' "$1"
}

get_sb_versplat() {
    local vers plat

    vers=$("$1" version | awk '/^sing-box version/ {print $3}' | head -n 1)
    plat=$("$1" version | awk '/^Environment:/ {print $3}' | head -n 1)
    echo "$vers $plat"
}

get_sb_version() {
    local version

    version=$("$1" version | awk '/^sing-box version/ {print $3}' | head -n 1)
    echo "$version"
}

self_copy() {
    local destination="$1"
    cp "$0" "$destination"
}

silent_create_dir() {
    mkdir -p "$1"
    chmod 775 "$1"
}

sing_box_start() {
    echo "$MESSAGE17"
    while true; do
        read -p "$MESSAGE18" choice
        case "$choice" in
            0) echo "$MESSAGE19"; break ;;
            1) start_sing_box; break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

update_tun_interface() {
    tun_interface=""
    in_block=0
    block=""

    while IFS= read -r line; do
        case "$line" in
            *'{'*) 
                block="$line"
                in_block=1
                continue ;;
        esac

        if [ "$in_block" -eq 1 ]; then
            block="$block
$line"
            case "$line" in
                *'}'*) 
                    in_block=0
                    echo "$block" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"tun\"" || continue
                    echo "$block" | grep -q '^[[:space:]]*"interface_name"[[:space:]]*:' || continue
                    tun_interface=$(echo "$block" | sed -n 's/^[[:space:]]*"interface_name"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p')
                    [ -n "$tun_interface" ] && break ;;
            esac
        fi
    done < "$SB_CONFIG"

    if [ -z "$tun_interface" ]; then
        sed -i "s/^TUN_INTERFACE=.*/TUN_INTERFACE=\"\"/" "$SBS_CONF"
    else
        sed -i "s/^TUN_INTERFACE=.*/TUN_INTERFACE=\"$tun_interface\"/" "$SBS_CONF"
    fi
}

extract_listen_port() {
    var_name="$1"
    type_value="$2"
    listen_port=""
    in_block=0
    block=""

    while IFS= read -r line; do
        case "$line" in
            *'{'*) 
                block="$line"
                in_block=1
                continue ;;
        esac

        if [ "$in_block" -eq 1 ]; then
            block="$block
$line"
            case "$line" in
                *'}'*) 
                    in_block=0
                    echo "$block" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"$type_value\"" || continue
                    echo "$block" | grep -q '^[[:space:]]*"listen_port"[[:space:]]*:' || continue
                    listen_port=$(echo "$block" | sed -n 's/^[[:space:]]*"listen_port"[[:space:]]*:[[:space:]]*\([0-9]*\).*/\1/p')
                    [ -n "$listen_port" ] && break ;;
            esac
        fi
    done < "$SB_CONFIG"

    if [ -z "$listen_port" ]; then
        sed -i "s/^$var_name=.*/$var_name=\"\"/" "$SBS_CONF"
    else
        sed -i "s/^$var_name=.*/$var_name=\"$listen_port\"/" "$SBS_CONF"
    fi
}

fakeip_check() {
    found_block=0
    enabled_required=0
    enabled_found=0
    inet4_range=""
    in_block=0

    while IFS= read -r line || [ -n "$line" ]; do
        if [ $in_block -eq 0 ]; then
            if echo "$line" | grep -q '^[[:space:]]*"fakeip"[[:space:]]*:[[:space:]]*{' ; then
                in_block=1
                found_block=1
                enabled_required=1
                enabled_found=0
                inet4_range=""
                continue
            fi
            if echo "$line" | grep -q '^[[:space:]]*"type"[[:space:]]*:[[:space:]]*"fakeip"'; then
                in_block=1
                found_block=1
                enabled_required=0
                enabled_found=1
                inet4_range=""
                continue
            fi
        else
            echo "$line" | grep -q '}' && in_block=0
            if [ $in_block -eq 0 ]; then
                break
            fi
            if [ $enabled_required -eq 1 ]; then
                echo "$line" | grep -q '^[[:space:]]*"enabled"[[:space:]]*:[[:space:]]*true' && enabled_found=1
            fi
            if echo "$line" | grep -q '^[[:space:]]*"inet4_range"[[:space:]]*:'; then
                inet4_range=$(echo "$line" | sed -n 's/^[[:space:]]*"inet4_range"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
            fi
        fi
    done < "$SB_CONFIG"

    if [ $found_block -eq 1 ] && [ $enabled_found -eq 1 ] && [ -n "$inet4_range" ]; then
        sed -i "s|^FAKEIP_SUBNET=.*|FAKEIP_SUBNET=\"$inet4_range\"|" "$SBS_CONF"
    else
        sed -i "s|^FAKEIP_SUBNET=.*|FAKEIP_SUBNET=\"\"|" "$SBS_CONF"
    fi
}

get_main_ips() {
    ip -4 route show | awk '{print $1}' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/[0-9]+)?$' | while read addr; do
        case "$addr" in
            */*) echo "$addr" ;;
            *) echo "$addr/32" ;;
        esac
    done
}

start_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    echo ""
    is_running && { log_msg "$MESSAGE21"; exit 1; }

    all_entries=$(printf "%s\n" $DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS})
    duplicates=$(echo "$all_entries" | sort | uniq -d)
    if [ -n "$duplicates" ]; then
        printf "$MESSAGE190\n" "$duplicates"
        exit 1
    fi

    log_msg "$MESSAGE200"
    update_tun_interface
    extract_listen_port TPROXY_PORT tproxy
    check_wan_ports
    fakeip_check
    source "$SBS_CONF"

    if [ -n "$TUN_INTERFACE" ]; then
        FW_RULES="FORWARD -i $TUN_INTERFACE -j ACCEPT
        FORWARD -o $TUN_INTERFACE -j ACCEPT
        INPUT -i $TUN_INTERFACE -j ACCEPT
        OUTPUT -o $TUN_INTERFACE -j ACCEPT"
        lsmod | grep -q "^tun " || { log_msg "$MESSAGE22"; modprobe tun; sleep 3; }
    elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
        lsmod | grep -q "^xt_TPROXY " || { log_msg "$MESSAGE191"; modprobe xt_TPROXY; sleep 3; }
    fi

    log_msg "$MESSAGE20"
    $SB_PATH run -c $SB_CONFIG &
    sleep 5
    is_running || { log_msg "$MESSAGE201"; exit 1; }
    if [ -n "$TUN_INTERFACE" ]; then
        echo 2 > /proc/sys/net/ipv4/conf/$TUN_INTERFACE/rp_filter
    fi
# Проверка наличия tun или tproxy интерфейса
    if [ -n "$TUN_INTERFACE" ]; then
        if ip link show "$TUN_INTERFACE" >/dev/null 2>&1; then
            log_msg "$(printf "$MESSAGE23\n" "$TUN_INTERFACE")"
        else
            log_msg "$MESSAGE24"
        fi
    elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
        log_msg "$MESSAGE238"
    fi
# Добавление правил nat и обновление скрипта nat-start
    if [ -n "$TUN_INTERFACE" ] && [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; } && [ -n "$DNS_PORT" ]; then
        sed -i "/sing-box-script/d" "$NAT_SCRIPT"
        log_msg "$MESSAGE25"
        iptables -t nat -D PREROUTING -j SBS-NAT 2>/dev/null
        iptables -t nat -F SBS-NAT 2>/dev/null
        iptables -t nat -N SBS-NAT 2>/dev/null
        iptables -t nat -I PREROUTING -j SBS-NAT
        iptables -t nat -I SBS-NAT -p tcp -m mark --mark $FW_MARK --dport 53 -j DNAT --to-destination 1.1.1.1:$DNS_PORT
        iptables -t nat -I SBS-NAT -p udp -m mark --mark $FW_MARK --dport 53 -j DNAT --to-destination 1.1.1.1:$DNS_PORT
        update_script "$NAT_SCRIPT" "( sleep 15 # sing-box-script-nat
iptables -t nat -D PREROUTING -j SBS-NAT 2>/dev/null # sing-box-script-nat
iptables -t nat -F SBS-NAT 2>/dev/null # sing-box-script-nat
iptables -t nat -N SBS-NAT 2>/dev/null # sing-box-script-nat
iptables -t nat -I PREROUTING -j SBS-NAT # sing-box-script-nat
iptables -t nat -I SBS-NAT -p tcp -m mark --mark $FW_MARK --dport 53 -j DNAT --to-destination 1.1.1.1:$DNS_PORT # sing-box-script-nat
iptables -t nat -I SBS-NAT -p udp -m mark --mark $FW_MARK --dport 53 -j DNAT --to-destination 1.1.1.1:$DNS_PORT; ) & # sing-box-script-nat"
    fi
# Добавление правил mangle и обновление скрипта nat-start
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; } && [ -n "$FW_MARK" ]; then
        log_msg "$MESSAGE192"
        iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null
        iptables -t mangle -F SBS-MANGLE 2>/dev/null
        iptables -t mangle -N SBS-MANGLE 2>/dev/null
        iptables -t mangle -I PREROUTING -j SBS-MANGLE
        update_script "$NAT_SCRIPT" "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBS-MANGLE # sing-box-script-mangle"

        for IP in $DEVICE_IPS; do
            if ! echo "$IP" | grep -q '/'; then
                ipset create sbsinc-ipset hash:ip
                for IP in $DEVICE_IPS; do
                    if ! echo "$IP" | grep -q '/'; then
                        ipset add sbsinc-ipset "$IP"
                    fi
                done
                break
            fi
        done
        for IP in ${FAKEIP_SUBNET:+$DEVICE_FIPS}; do
            if ! echo "$IP" | grep -q '/'; then
                ipset create sbsfinc-ipset hash:ip
                for IP in $DEVICE_FIPS; do
                    if ! echo "$IP" | grep -q '/'; then
                        ipset add sbsfinc-ipset "$IP"
                    fi
                done
                break
            fi
        done
        for IP in $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$EXC_DEVICE_FIPS}; do
            if ! echo "$IP" | grep -q '/'; then
                ipset create sbsexc-ipset hash:ip
                for IP in $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$EXC_DEVICE_FIPS}; do
                    if ! echo $IP | grep -q '/'; then
                        ipset add sbsexc-ipset $IP
                    fi
                done
                break
            fi
        done
        sorted_subnets=$(echo "$DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS}" | tr ' ' '\n' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+' | sort -t '/' -k2,2n)
        if [ -n "$sorted_subnets" ]; then
            echo "$sorted_subnets" | while read -r subnet; do
                if echo "$DEVICE_IPS" | grep -qw "$subnet"; then
                    iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN # sing-box-script-mangle"
                    if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                        iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                    else
                        iptables -t mangle -I SBS-MANGLE -s $subnet -j MARK --set-mark $FW_MARK
                        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -s $subnet -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                    fi
                elif echo "$EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS}" | grep -qw "$subnet"; then
                    iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN # sing-box-script-mangle"
                fi
            done
        fi
        if ipset list sbsinc-ipset >/dev/null 2>&1; then
            iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j RETURN # sing-box-script-mangle"
            if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
            else
                iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j MARK --set-mark $FW_MARK
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
            fi
        fi
        if ipset list sbsfinc-ipset >/dev/null 2>&1; then
            iptables -t mangle -I SBS-MANGLE -m set --match-set sbsfinc-ipset src -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsfinc-ipset src -j RETURN # sing-box-script-mangle"
        fi
        if [ -n "$FAKEIP_SUBNET" ]; then
            iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j RETURN # sing-box-script-mangle"
            if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
            else
                iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
            fi
        fi
        get_main_ips | while read mainip; do
            iptables -t mangle -I SBS-MANGLE -d $mainip -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -d $mainip -j RETURN # sing-box-script-mangle"
        done
        iptables -t mangle -I SBS-MANGLE -p udp --dport 67 -j RETURN
        iptables -t mangle -I SBS-MANGLE -p udp --dport 68 -j RETURN
        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p udp --dport 67 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp --dport 68 -j RETURN # sing-box-script-mangle"

        if [ -n "$sorted_subnets" ]; then
            echo "$sorted_subnets" | while read -r subnet; do
                if echo "$DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}" | grep -qw "$subnet"; then
                    iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN
                    iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle"
                    if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                        iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                    else
                        iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j MARK --set-mark $FW_MARK
                        iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j MARK --set-mark $FW_MARK
                        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                    fi
                elif echo "$EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$EXC_DEVICE_FIPS}" | grep -qw "$subnet"; then
                    iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN
                    iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle"
                fi
            done
        fi
        for setname in sbsinc-ipset sbsfinc-ipset; do
            if ipset list "$setname" >/dev/null 2>&1; then
                iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src --dport 53 -j RETURN
                iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src --dport 53 -j RETURN
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src --dport 53 -j RETURN # sing-box-script-mangle"
                if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                    iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                    iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                else
                    iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src --dport 53 -j MARK --set-mark $FW_MARK
                    iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src --dport 53 -j MARK --set-mark $FW_MARK
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                fi
            fi
        done
        if ipset list sbsexc-ipset >/dev/null 2>&1; then
            iptables -t mangle -I SBS-MANGLE -m set --match-set sbsexc-ipset src -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsexc-ipset src -j RETURN # sing-box-script-mangle"
        fi
        update_script "$NAT_SCRIPT" ") & # sing-box-script-mangle"
    fi
# То же, но для использования sing-box в качестве чисто DNS сервера с fakeip для конечных устройств или для AGH, попросили такую возможность
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -z "$DEVICE_IPS" ] && [ -z "$DEVICE_FIPS" ] && [ -n "$FAKEIP_SUBNET" ] && [ -n "$FW_MARK" ]; then
        log_msg "$MESSAGE192"
        sed -i "/sing-box-script/d" "$NAT_SCRIPT"
        iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null
        iptables -t mangle -F SBS-MANGLE 2>/dev/null
        iptables -t mangle -N SBS-MANGLE 2>/dev/null
        iptables -t mangle -I PREROUTING -j SBS-MANGLE
        update_script "$NAT_SCRIPT" "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBS-MANGLE # sing-box-script-mangle"
        if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
            iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
            iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK; ) & # sing-box-script-mangle"
        else
            iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK; ) & # sing-box-script-mangle"
        fi
    fi
# Добавление правил файрвола, маршрутов и правил маршрутизации и обновление скрипта firewall-start
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -n "$FW_MARK" ]; then
        if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
            log_msg "$MESSAGE27"
            ip route add local 0.0.0.0/0 dev lo table $ROUTE_TABLE
        else
            log_msg "$MESSAGE26"
            echo "$FW_RULES" | while read -r rule; do
                manage_iptables "add" "$rule"
                update_script "$FW_SCRIPT" "iptables -I $rule # sing-box-script"
            done
            log_msg "$MESSAGE27"
            ip route add default dev $TUN_INTERFACE table $ROUTE_TABLE
        fi
        ip rule add fwmark $FW_MARK lookup $ROUTE_TABLE priority 5353
    fi
# Открываем указанные порты из WAN в роутер для режима сервера
    if [ -n "$WAN_PORTS" ]; then
        log_msg "$(printf "$MESSAGE28\n" "$WAN_PORTS")"
        for entry in $WAN_PORTS; do
            wan_port=$(echo "$entry" | cut -d ':' -f 2)
            if ! iptables-save | grep -q -- "-A INPUT -p tcp -m tcp --dport $wan_port -j ACCEPT"; then
                iptables -I INPUT -p tcp --dport "$wan_port" -j ACCEPT
            fi
            if ! iptables-save | grep -q -- "-A INPUT -p udp -m udp --dport $wan_port -j ACCEPT"; then
                iptables -I INPUT -p udp --dport "$wan_port" -j ACCEPT
            fi
            update_script "$FW_SCRIPT" "iptables -I INPUT -p tcp --dport "$wan_port" -j ACCEPT # sing-box-script
iptables -I INPUT -p udp --dport "$wan_port" -j ACCEPT # sing-box-script"
        done
    fi
    log_msg "$MESSAGE29"
    $SBS_MON &
    update_script "$SS_SCRIPT" "$SS_LINES # sing-box-script"
    log_msg "$MESSAGE30"
}

stop_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    echo ""
    log_msg "$MESSAGE31"

    kill $(ps | grep "[s]bs-monitor" | awk '{print $1}') 2>/dev/null

    if [ -n "$TUN_INTERFACE" ]; then
        FW_RULES="FORWARD -i $TUN_INTERFACE -j ACCEPT
        FORWARD -o $TUN_INTERFACE -j ACCEPT
        INPUT -i $TUN_INTERFACE -j ACCEPT
        OUTPUT -o $TUN_INTERFACE -j ACCEPT"
    fi

    log_msg "$MESSAGE32"
    sed -i "/sing-box-script/d" "$SS_SCRIPT"
# Очистка системных скриптов
    sed -i "/sing-box-script/d" "$FW_SCRIPT"
    sed -i "/sing-box-script/d" "$NAT_SCRIPT"
# Удаление правил iptables для открытых WAN портов
    if [ -n "$WAN_PORTS" ]; then
        log_msg "$(printf "$MESSAGE33\n" "$WAN_PORTS")"
        for entry in $WAN_PORTS; do
            wan_port=$(echo "$entry" | cut -d ':' -f 2)
            iptables -D INPUT -p udp --dport "$wan_port" -j ACCEPT
            iptables -D INPUT -p tcp --dport "$wan_port" -j ACCEPT
        done
    fi
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -n "$FW_MARK" ]; then
# Удаление правил маршрутизации, маршрутов и правил iptables
        log_msg "$MESSAGE34"
        ip rule del fwmark $FW_MARK lookup $ROUTE_TABLE >/dev/null 2>&1
        ip route flush table $ROUTE_TABLE
        if [ -n "$TUN_INTERFACE" ]; then
            log_msg "$MESSAGE35"
            echo "$FW_RULES" | while read -r rule; do
                manage_iptables "remove" "$rule" >/dev/null 2>&1
            done
        fi
# Удаление правил mangle
        log_msg "$MESSAGE193"
        iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null
        iptables -t mangle -F SBS-MANGLE 2>/dev/null
        iptables -t mangle -X SBS-MANGLE 2>/dev/null
        if ipset list sbsexc-ipset >/dev/null 2>&1; then
            ipset destroy sbsexc-ipset >/dev/null 2>&1
        fi
        if ipset list sbsinc-ipset >/dev/null 2>&1; then
            ipset destroy sbsinc-ipset >/dev/null 2>&1
        fi
        if ipset list sbsfinc-ipset >/dev/null 2>&1; then
            ipset destroy sbsfinc-ipset >/dev/null 2>&1
        fi
# Удаление правил nat
        log_msg "$MESSAGE36"
        iptables -t nat -D PREROUTING -j SBS-NAT 2>/dev/null
        iptables -t nat -F SBS-NAT 2>/dev/null
        iptables -t nat -X SBS-NAT 2>/dev/null
    fi

    kill $(ps | grep "[s]ing-box" | awk '{print $1}') 2>/dev/null

    log_msg "$MESSAGE37"
}

configure_interface() {
    source "$SBS_CONF"

    if [ -z "$DEVICE_IPS" ]; then
        echo ""
        echo "$MESSAGE38"
        while true; do
            read -p "$MESSAGE18" initial_choice
            case "$initial_choice" in
                0) echo "$MESSAGE39"; break ;;
                1) read -p "$MESSAGE40" new_ips
                   if [ -z "$new_ips" ]; then
                       echo "$MESSAGE41"
                   else
                       DEVICE_IPS="$new_ips"
                       sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"$new_ips\"|" "$SBS_CONF"
                       echo "$MESSAGE42"
                   fi; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        echo ""
        printf "$MESSAGE43\n" "$DEVICE_IPS"
        while true; do
            echo ""
            echo "$MESSAGE44"
            echo "$MESSAGE45"
            echo "$MESSAGE46"
            read -p "$MESSAGE47" action_choice
            case "$action_choice" in
                1) read -p "$MESSAGE48" ips_input
                   if [ -z "$ips_input" ]; then
                       echo "$MESSAGE49"
                   else
                       for ip in $ips_input; do
                           if echo "$DEVICE_IPS" | grep -q "$ip"; then
                               DEVICE_IPS=$(echo "$DEVICE_IPS" | tr ' ' '\n' | grep -v "^$ip$" | tr '\n' ' ' | xargs)
                               printf "$MESSAGE50\n" "$ip"
                           else
                               DEVICE_IPS="${DEVICE_IPS:+$DEVICE_IPS }$ip"
                               printf "$MESSAGE51\n" "$ip"
                           fi
                       done
                       sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"$DEVICE_IPS\"|" "$SBS_CONF"
                   fi; break ;;
                2) read -p "$MESSAGE52" new_ips
                   if [ -z "$new_ips" ]; then
                       DEVICE_IPS=""
                       sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"\"|" "$SBS_CONF"
                       echo "$MESSAGE53"
                   else
                       DEVICE_IPS="$new_ips"
                       sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"$new_ips\"|" "$SBS_CONF"
                       echo "$MESSAGE54"
                   fi; break ;;
                0) echo "$MESSAGE55"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi

    cidrs=""
    for ip in $DEVICE_IPS; do
        if echo "$ip" | grep -q '/'; then
            cidrs="$cidrs $ip"
        fi
    done
    if [ -n "$cidrs" ]; then
        if [ -z "$EXC_DEVICE_IPS" ]; then
            echo ""
            printf "$MESSAGE56\n" "$cidrs"
            echo "$MESSAGE57"
            while true; do
                read -p "$MESSAGE18" initial_exc_choice
                case "$initial_exc_choice" in
                    0) echo "$MESSAGE39"; break ;;
                    1) read -p "$MESSAGE40" exc_new_ips
                       if [ -z "$exc_new_ips" ]; then
                           echo "$MESSAGE58"
                       else
                           EXC_DEVICE_IPS="$exc_new_ips"
                           sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"$exc_new_ips\"|" "$SBS_CONF"
                           echo "$MESSAGE59"
                       fi; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        else
            echo ""
            printf "$MESSAGE56\n" "$cidrs"
            printf "$MESSAGE60\n" "$EXC_DEVICE_IPS"
            while true; do
            echo ""
            echo "$MESSAGE44"
            echo "$MESSAGE45"
            echo "$MESSAGE46"
            read -p "$MESSAGE47" action_exc_choice
                case "$action_exc_choice" in
                    1) read -p "$MESSAGE48" exc_ips_input
                       if [ -z "$exc_ips_input" ]; then
                           echo "$MESSAGE61"
                       else
                           for ip in $exc_ips_input; do
                               if echo "$EXC_DEVICE_IPS" | grep -q "$ip"; then
                                   EXC_DEVICE_IPS=$(echo "$EXC_DEVICE_IPS" | tr ' ' '\n' | grep -v "^$ip$" | tr '\n' ' ' | xargs)
                                   printf "$MESSAGE62\n" "$ip"
                               else
                                   EXC_DEVICE_IPS="${EXC_DEVICE_IPS:+$EXC_DEVICE_IPS }$ip"
                                   printf "$MESSAGE63\n" "$ip"
                               fi
                           done
                           sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"$EXC_DEVICE_IPS\"|" "$SBS_CONF"
                       fi; break ;;
                    2) read -p "$MESSAGE52" exc_new_ips
                       if [ -z "$exc_new_ips" ]; then
                           EXC_DEVICE_IPS=""
                           sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"\"|" "$SBS_CONF"
                           echo "$MESSAGE64"
                       else
                           EXC_DEVICE_IPS="$exc_new_ips"
                           sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"$exc_new_ips\"|" "$SBS_CONF"
                           echo "$MESSAGE65"
                       fi; break ;;
                    0) echo "$MESSAGE55"; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        fi
    else
        EXC_DEVICE_IPS=""
        sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"\"|" "$SBS_CONF"
    fi

    echo "$MESSAGE66"
}

configure_finterface() {
    source "$SBS_CONF"

    if [ -z "$DEVICE_FIPS" ]; then
        echo ""
        echo "$MESSAGE67"
        while true; do
            read -p "$MESSAGE18" initial_fchoice
            case "$initial_fchoice" in
                0) echo "$MESSAGE39"; break ;;
                1) read -p "$MESSAGE40" new_fips
                   if [ -z "$new_fips" ]; then
                       echo "$MESSAGE41"
                   else
                       DEVICE_FIPS="$new_fips"
                       sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"$new_fips\"|" "$SBS_CONF"
                       echo "$MESSAGE42"
                   fi; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        echo ""
        printf "$MESSAGE68\n" "$DEVICE_FIPS"
        while true; do
            echo ""
            echo "$MESSAGE44"
            echo "$MESSAGE45"
            echo "$MESSAGE46"
            read -p "$MESSAGE47" action_fchoice
            case "$action_fchoice" in
                1) read -p "$MESSAGE48" ips_finput
                   if [ -z "$ips_finput" ]; then
                       echo "$MESSAGE49"
                   else
                       for ip in $ips_finput; do
                           if echo "$DEVICE_FIPS" | grep -q "$ip"; then
                               DEVICE_FIPS=$(echo "$DEVICE_FIPS" | tr ' ' '\n' | grep -v "^$ip$" | tr '\n' ' ' | xargs)
                               printf "$MESSAGE69\n" "$ip"
                           else
                               DEVICE_FIPS="${DEVICE_FIPS:+$DEVICE_FIPS }$ip"
                               printf "$MESSAGE70\n" "$ip"
                           fi
                       done
                       sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"$DEVICE_FIPS\"|" "$SBS_CONF"
                   fi; break ;;
                2) read -p "$MESSAGE52" new_fips
                   if [ -z "$new_fips" ]; then
                       DEVICE_FIPS=""
                       sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"\"|" "$SBS_CONF"
                       echo "$MESSAGE71"
                   else
                       DEVICE_FIPS="$new_fips"
                       sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"$new_fips\"|" "$SBS_CONF"
                       echo "$MESSAGE72"
                   fi; break ;;
                0) echo "$MESSAGE55"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi

    fcidrs=""
    for ip in $DEVICE_FIPS; do
        if echo "$ip" | grep -q '/'; then
            fcidrs="$fcidrs $ip"
        fi
    done
    if [ -n "$fcidrs" ]; then
        if [ -z "$EXC_DEVICE_FIPS" ]; then
            echo ""
            printf "$MESSAGE73\n" "$fcidrs"
            echo "$MESSAGE74"
            while true; do
                read -p "$MESSAGE18" initial_exc_fchoice
                case "$initial_exc_fchoice" in
                    0) echo "$MESSAGE39"; break ;;
                    1) read -p "$MESSAGE40" exc_new_fips
                       if [ -z "$exc_new_fips" ]; then
                           echo "$MESSAGE75"
                       else
                           EXC_DEVICE_FIPS="$exc_new_fips"
                           sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"$exc_new_fips\"|" "$SBS_CONF"
                           echo "$MESSAGE76"
                       fi; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        else
            echo ""
            printf "$MESSAGE73\n" "$fcidrs"
            printf "$MESSAGE77\n" "$EXC_DEVICE_FIPS"
            while true; do
            echo ""
            echo "$MESSAGE44"
            echo "$MESSAGE45"
            echo "$MESSAGE46"
            read -p "$MESSAGE47" action_exc_fchoice
                case "$action_exc_fchoice" in
                    1) read -p "$MESSAGE48" exc_ips_finput
                       if [ -z "$exc_ips_finput" ]; then
                           echo "$MESSAGE78"
                       else
                           for ip in $exc_ips_finput; do
                               if echo "$EXC_DEVICE_FIPS" | grep -q "$ip"; then
                                   EXC_DEVICE_FIPS=$(echo "$EXC_DEVICE_FIPS" | tr ' ' '\n' | grep -v "^$ip$" | tr '\n' ' ' | xargs)
                                   printf "$MESSAGE79\n" "$ip"
                               else
                                   EXC_DEVICE_FIPS="${EXC_DEVICE_FIPS:+$EXC_DEVICE_FIPS }$ip"
                                   printf "$MESSAGE80\n" "$ip"
                               fi
                           done
                           sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"$EXC_DEVICE_FIPS\"|" "$SBS_CONF"
                       fi; break ;;
                    2) read -p "$MESSAGE52" exc_new_fips
                       if [ -z "$exc_new_fips" ]; then
                           EXC_DEVICE_FIPS=""
                           sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"\"|" "$SBS_CONF"
                           echo "$MESSAGE81"
                       else
                           EXC_DEVICE_FIPS="$exc_new_fips"
                           sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"$exc_new_fips\"|" "$SBS_CONF"
                           echo "$MESSAGE82"
                       fi; break ;;
                    0) echo "$MESSAGE55"; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        fi
    else
        EXC_DEVICE_FIPS=""
        sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"\"|" "$SBS_CONF"
    fi

    echo "$MESSAGE66"
}

configure_table() {
    source "$SBS_CONF"

    echo ""
    printf "$MESSAGE83\n" "$ROUTE_TABLE"
    echo "$MESSAGE84"
    while true; do
        read -p "$MESSAGE18" choice
        case "$choice" in
            0) echo "$MESSAGE85"; break ;;
            1) read -p "$MESSAGE86" new_table
               ROUTE_TABLE="$new_table"
               sed -i "s|^ROUTE_TABLE=\".*\"$|ROUTE_TABLE=\"$new_table\"|" "$SBS_CONF"
               log_msg "$(printf "$MESSAGE87\n" "$ROUTE_TABLE")"; break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
    echo "$MESSAGE66"
}

configure_tpmark() {
    source "$SBS_CONF"

    echo ""
    printf "$MESSAGE197\n" "$FW_MARK"
    while true; do
        read -p "$MESSAGE18" choice
        case "$choice" in
            0) echo "$MESSAGE199"; break ;;
            1) read -p "$MESSAGE198" new_tpmark
               FW_MARK="$new_tpmark"
               sed -i "s|^FW_MARK=\".*\"$|FW_MARK=\"$new_tpmark\"|" "$SBS_CONF"
               log_msg "$(printf "$MESSAGE147\n" "$FW_MARK")"; break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
    echo "$MESSAGE66"
}

setup_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    if [ -z "$TUN_INTERFACE" ] && [ -z "$TPROXY_PORT" ]; then
        echo ""
        echo "$MESSAGE88"
        exit 0
    fi
    if is_running; then
        echo ""
        echo "$MESSAGE89"
        while true; do
            read -p "$MESSAGE18" choice
            case "$choice" in
                0) echo "$MESSAGE90"; exit 0 ;;
                1) stop_sing_box; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi

    echo "$MESSAGE200"
    update_tun_interface
    extract_listen_port TPROXY_PORT tproxy
    fakeip_check
    source "$SBS_CONF"

    if [ -z "$FAKEIP_SUBNET" ]; then
        while true; do
            echo "$MESSAGE91"
            echo ""
            echo "$MESSAGE92"
            echo "$MESSAGE93"
            echo "2. $MESSAGE94"
            echo "0. $MESSAGE95"
            read -p "$MESSAGE99 [0-2]: " if_choice
            case "$if_choice" in
                1) configure_interface; source "$SBS_CONF" ;;
                2) if ! setup_pro; then continue; fi ;;
                0) break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        while true; do
            echo ""
            echo "$MESSAGE91"
            echo ""
            echo "$MESSAGE96"
            echo "$MESSAGE93"
            echo "$MESSAGE97"
            echo "3. $MESSAGE94"
            echo "0. $MESSAGE95"
            read -p "$MESSAGE99 [0-3]: " if_choice
            case "$if_choice" in
                1) configure_interface; source "$SBS_CONF" ;;
                2) configure_finterface; source "$SBS_CONF" ;;
                3) if ! setup_pro; then continue; fi ;;
                0) break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
    sing_box_start
}

setup_pro() {
    if [ -n "$TUN_INTERFACE" ]; then
        while true; do
            echo ""
            echo "$MESSAGE194"
            echo ""
            echo "$MESSAGE98"
            echo "$MESSAGE196"
            read -p "$MESSAGE99 [0-1]: " if_choice
            case "$if_choice" in
                1) configure_table; source "$SBS_CONF" ;;
                0) return 1 ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
        while true; do
            echo ""
            echo "$MESSAGE194"
            echo ""
            echo "$MESSAGE98"
            echo "$MESSAGE195"
            echo "$MESSAGE196"
            read -p "$MESSAGE99 [0-2]: " if_choice
            case "$if_choice" in
                1) configure_table; source "$SBS_CONF" ;;
                2) configure_tpmark; source "$SBS_CONF" ;;
                0) return 1 ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
}

download_updates() {
    source "$SBS_CONF"
    if [ "$(uname -m)" = "aarch64" ]; then
        SB_ARCHIVE_PATH="$SB_DOWNLOAD_DIR/sing-box-linux-arm64.tar.gz"
        ARCHIVE_SUFFIX="linux-arm64.tar.gz"
    else
        SB_ARCHIVE_PATH="$SB_DOWNLOAD_DIR/sing-box-linux-armv7.tar.gz"
        ARCHIVE_SUFFIX="linux-armv7.tar.gz"
    fi
    if [ "$SB_REPO" = "customa" ] && [ -z "$CUSTOM_REPO_A" ]; then
        sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF"
        SB_REPO="original"
    elif [ "$SB_REPO" = "customb" ] && [ -z "$CUSTOM_REPO_B" ]; then
        sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF"
        SB_REPO="original"
    fi
    if [ "$CORE_VERS" = "given" ] && [ -z "$GIVEN_VERS" ]; then
        sed -i 's|^CORE_VERS="[^"]*"|CORE_VERS="release"|' "$SBS_CONF"
        CORE_VERS="release"
    fi
    UPD_SB_URL=$SB_URL
    if [ "$SB_REPO" = "customa" ]; then
        UPD_SB_URL=$(echo "$SB_URL" | sed "s|SagerNet/sing-box|$CUSTOM_REPO_A|")
    elif [ "$SB_REPO" = "customb" ]; then
        UPD_SB_URL=$(echo "$SB_URL" | sed "s|SagerNet/sing-box|$CUSTOM_REPO_B|")
    fi
    echo ""
    echo "$MESSAGE100"
    rm -rf "$SB_DOWNLOAD_DIR"
    silent_create_dir "$SB_DOWNLOAD_DIR"
    wget -q -O $TEMP_SCRIPT_PATH "$SCRIPT_URL"

    MAX_RELEASES=${NUM_RELEASES:-30}
    MAX_PAGES=$(( (MAX_RELEASES + 29) / 30 ))
    SB_DOWNLOAD_URL=""
    page=1
    while [ "$page" -le "$MAX_PAGES" ]; do
        json=$(wget --quiet --header="Accept: application/vnd.github.v3+json" -O - "$UPD_SB_URL?page=$page")
        case "$CORE_VERS" in
            release)
                SB_DOWNLOAD_URL=$(awk -v suffix="$ARCHIVE_SUFFIX" '
                    BEGIN { found=0 }
                    /"prerelease": false/ { found=1 }
                    found && /"browser_download_url":/ && $0 ~ suffix {
                        gsub(/^.*"browser_download_url": *"/, "")
                        gsub(/".*$/, "")
                        print
                        exit
                    }
                ' <<EOF
$json
EOF
) ;;
            pre_release)
                SB_DOWNLOAD_URL=$(awk -v suffix="$ARCHIVE_SUFFIX" '
                    BEGIN { found=0 }
                    /"prerelease": true/ { found=1 }
                    found && /"browser_download_url":/ && $0 ~ suffix {
                        gsub(/^.*"browser_download_url": *"/, "")
                        gsub(/".*$/, "")
                        print
                        exit
                    }
                ' <<EOF
$json
EOF
) ;;
            given)
                SB_DOWNLOAD_URL=$(awk -v search="$GIVEN_VERS" -v suffix="$ARCHIVE_SUFFIX" '
                    index($0, "\"browser_download_url\"") && index($0, suffix) && index($0, search) {
                        gsub(/^.*"browser_download_url": *"/, "")
                        gsub(/".*$/, "")
                        print
                        exit
                    }
                ' <<EOF
$json
EOF
) ;;
        esac
        [ -n "$SB_DOWNLOAD_URL" ] && break
        page=$((page + 1))
    done
    ARCHIVE_PATH="$SB_ARCHIVE_PATH"
    DOWNLOAD_URL="$SB_DOWNLOAD_URL"

    if wget --spider -q "$DOWNLOAD_URL"; then
        wget -q -O "$ARCHIVE_PATH" "$DOWNLOAD_URL"
        tar -xzvf "$ARCHIVE_PATH" -C "$SB_DOWNLOAD_DIR" > /dev/null
        echo "$MESSAGE101"
    else
        echo "$MESSAGE219"
    fi
}

update_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    download_updates
    update_sing_box_menu
}

update_sing_box_menu() {
    while true; do
        case "$SB_REPO" in
          original) additionally="$MESSAGE207" ;;
          customa) additionally="$MESSAGE213 A: $CUSTOM_REPO_A" ;;
          customb) additionally="$MESSAGE213 B: $CUSTOM_REPO_B" ;;
        esac
        case "$CORE_VERS" in
          release) given_value="$MESSAGE226" ;;
          pre_release) given_value="$MESSAGE227" ;;
          given) given_value="$MESSAGE228 $GIVEN_VERS" ;;
        esac
        [ -f "$ARCHIVE_PATH" ] && singbox_file=$(find "$SB_DOWNLOAD_DIR" -name "sing-box" -exec test -f {} \; -print) && [ -n "$singbox_file" ] && chmod 775 "$singbox_file"
        sbs_vers=$(get_sbs_version $SCRIPT_PATH)
        if [ -f "$SB_PATH" ]; then
            sb_vers=$(get_sb_version "$SB_PATH")
        else
            sb_vers=""
        fi
        sbs_vers_new=$(get_sbs_version $TEMP_SCRIPT_PATH)
        if [ -f "$singbox_file" ]; then
            sb_vers_new=$(get_sb_version $singbox_file)
        else
            sb_vers_new=""
        fi
        echo ""
        echo "$MESSAGE102"
        echo ""
        is_running && echo "$MESSAGE103"
        printf "$MESSAGE104\n" "$sbs_vers" "$sbs_vers_new"
        printf "$MESSAGE105\n" "${sb_vers:-$MESSAGE169}" "${sb_vers_new:-$MESSAGE169.}"
        printf "$MESSAGE235\n" "$additionally" "$given_value"
        if [ -n "$NUM_RELEASES" ]; then
            printf "   $MESSAGE209\n" "$NUM_RELEASES"
        else
            printf "   $MESSAGE209\n" "30"
        fi
        echo "0. $MESSAGE95"
        read -p "$MESSAGE99 [0-3]: " choice
        case "$choice" in
            1) is_running && stop_sing_box; update_sbs; break ;;
            2) [ -n "$sb_vers_new" ] && { is_running && stop_sing_box; updcore_sing_box; source "$SBS_CONF"; download_updates; continue; } || echo "$MESSAGE219" ;;
            3) change_repo_vers; source "$SBS_CONF"; download_updates; continue ;;
            0) rm -rf "$SB_DOWNLOAD_DIR"; echo "$MESSAGE106"; is_running || sing_box_start; exit 0 ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

change_repo_vers() {
    while true; do
        echo ""
        echo "$MESSAGE234"
        printf "$MESSAGE202\n" "$additionally"
        printf "$MESSAGE221\n" "$given_value"
        if [ -n "$NUM_RELEASES" ]; then
            printf "   $MESSAGE209\n" "$NUM_RELEASES"
        else
            printf "   $MESSAGE209\n" "30"
        fi
        echo "0. $MESSAGE206"
        read -p "$MESSAGE99 [0-2]: " choice_repo_vers
        case "$choice_repo_vers" in
            1) change_sing_box_repo; source "$SBS_CONF"; continue ;;
            2) change_core_vers; source "$SBS_CONF"; continue ;;
            0) return ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

change_sing_box_repo() {
    while true; do
        source "$SBS_CONF"
        [ "$SB_REPO" = "customa" ] && [ -z "$CUSTOM_REPO_A" ] && sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF" && SB_REPO="original"
        [ "$SB_REPO" = "customb" ] && [ -z "$CUSTOM_REPO_B" ] && sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF" && SB_REPO="original"
        case "$SB_REPO" in
          original) additionally="$MESSAGE207" ;;
          customa) additionally="$MESSAGE213 A: $CUSTOM_REPO_A" ;;
          customb) additionally="$MESSAGE213 B: $CUSTOM_REPO_B" ;;
        esac
        echo ""
        echo "$MESSAGE203"
        echo "$additionally"
        echo "1. $MESSAGE204"
        printf "2. $MESSAGE205\n" "A"
        printf "3. $MESSAGE205\n" "B"
        echo "4. $MESSAGE211 A."
        [ -n "$CUSTOM_REPO_A" ] && printf "   $MESSAGE214\n" ": $CUSTOM_REPO_A"
        echo "5. $MESSAGE211 B."
        [ -n "$CUSTOM_REPO_B" ] && printf "   $MESSAGE214\n" ": $CUSTOM_REPO_B"
        echo "0. $MESSAGE218"
        read -p "$MESSAGE99 [0-5]: " choice_repo
        case "$choice_repo" in
            1) sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF" ;;
            2) [ -n "$CUSTOM_REPO_A" ] && sed -i 's|^SB_REPO="[^"]*"|SB_REPO="customa"|' "$SBS_CONF" || printf "$MESSAGE216\n" "A" ;;
            3) [ -n "$CUSTOM_REPO_B" ] && sed -i 's|^SB_REPO="[^"]*"|SB_REPO="customb"|' "$SBS_CONF" || printf "$MESSAGE216\n" "B" ;;
            4) echo ""
               echo "$MESSAGE210"
               read -p "$MESSAGE212 A: " newrepoa
               if [ -z "$newrepoa" ]; then
                   sed -i 's|^CUSTOM_REPO_A="[^"]*"|CUSTOM_REPO_A=""|' "$SBS_CONF"
               elif echo "$newrepoa" | grep -Eqv '^[^[:space:]/]+/[^[:space:]/]+$'; then
                   echo "$MESSAGE217"
               else
                   sed -i "s|^CUSTOM_REPO_A=\"[^\"]*\"|CUSTOM_REPO_A=\"$newrepoa\"|" "$SBS_CONF"
               fi ;;
            5) echo ""
               echo "$MESSAGE210"
               read -p "$MESSAGE212 B: " newrepob
               if [ -z "$newrepob" ]; then
                   sed -i 's|^CUSTOM_REPO_B="[^"]*"|CUSTOM_REPO_B=""|' "$SBS_CONF"
               elif echo "$newrepob" | grep -Eqv '^[^[:space:]/]+/[^[:space:]/]+$'; then
                   echo "$MESSAGE217"
               else
                   sed -i "s|^CUSTOM_REPO_B=\"[^\"]*\"|CUSTOM_REPO_B=\"$newrepob\"|" "$SBS_CONF"
               fi ;;
            0) return ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

change_core_vers() {
    while true; do
        source "$SBS_CONF"
        [ "$CORE_VERS" = "given" ] && [ -z "$GIVEN_VERS" ] && sed -i 's|^CORE_VERS="[^"]*"|CORE_VERS="release"|' "$SBS_CONF" && CORE_VERS="release"
        case "$CORE_VERS" in
          release) given_value="$MESSAGE226" ;;
          pre_release) given_value="$MESSAGE227" ;;
          given) given_value="$MESSAGE228 $GIVEN_VERS" ;;
        esac
        echo ""
        echo "$MESSAGE229"
        echo "$given_value"
        echo "1. $MESSAGE222"
        echo "2. $MESSAGE223"
        echo "3. $MESSAGE224"
        echo "4. $MESSAGE225"
        [ -n "$GIVEN_VERS" ] && printf "   $MESSAGE214\n" ": $GIVEN_VERS"
        echo "5. $MESSAGE233"
        [ -n "$NUM_RELEASES" ] && { printf "   $MESSAGE214" "$NUM_RELEASES"; echo " $MESSAGE215"; } || { printf "   $MESSAGE214" "30"; echo " $MESSAGE215"; }
        echo "0. $MESSAGE218"
        read -p "$MESSAGE99 [0-4]: " choice_vers
        case "$choice_vers" in
            1) sed -i 's|^CORE_VERS="[^"]*"|CORE_VERS="release"|' "$SBS_CONF" ;;
            2) sed -i 's|^CORE_VERS="[^"]*"|CORE_VERS="pre_release"|' "$SBS_CONF" ;;
            3) [ -n "$GIVEN_VERS" ] && sed -i 's|^CORE_VERS="[^"]*"|CORE_VERS="given"|' "$SBS_CONF" || echo "$MESSAGE231" ;;
            4) echo ""; read -p "$MESSAGE232: " new_given_vers; [ -z "$new_given_vers" ] && { sed -i 's|^GIVEN_VERS="[^"]*"|GIVEN_VERS=""|' "$SBS_CONF"; echo "$MESSAGE230"; } || { sed -i "s|^GIVEN_VERS=\"[^\"]*\"|GIVEN_VERS=\"$new_given_vers\"|" "$SBS_CONF"; } ;;
            5) echo ""; read -p "$MESSAGE208: " new_num_releases; [ -z "$new_num_releases" ] && { sed -i 's|^NUM_RELEASES="[^"]*"|NUM_RELEASES=""|' "$SBS_CONF"; } || { sed -i "s|^NUM_RELEASES=\"[^\"]*\"|NUM_RELEASES=\"$new_num_releases\"|" "$SBS_CONF"; } ;;
            0) return ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}
update_sbs() {
    echo ""
    echo "$MESSAGE107"
    cp $TEMP_SCRIPT_PATH $SCRIPT_PATH
    chmod 775 $SCRIPT_PATH
    [ -f "$LANG_EN" ] && { wget -q -O $LANG_EN $LANG_EN_URL && chmod 664 $LANG_EN; }
    [ -f "$LANG_RU" ] && { wget -q -O $LANG_RU $LANG_RU_URL && chmod 664 $LANG_RU; }

    cat << EOF > $TEMP_UPDATE
#!/bin/sh
exec $SCRIPT_PATH updmonandconf
EOF
    chmod 775 $TEMP_UPDATE
    # Удаляем файл, не используемый с версии 2.2.2
    rm -f $JFFS_SB_DIR/sbs-tmp
    exec $TEMP_UPDATE
}

updmonandconf_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    create_sbs_conf "$TEMP_SBS_CONF"
    comments=$(grep '^#' "$TEMP_SBS_CONF")
    vars_in_tmp=$(grep '^[A-Za-z0-9_]\+=' "$TEMP_SBS_CONF")
    existing_vars=$(grep '^[A-Za-z0-9_]\+=' "$SBS_CONF")
    {
        echo "$comments"
        echo ""
        for var in $vars_in_tmp; do
            name=$(echo "$var" | cut -d= -f1)
            old_value=$(echo "$existing_vars" | grep "^$name=")
            if [ -n "$old_value" ]; then
                echo "$old_value"
            else
                echo "$var"
            fi
        done
    } > "$SBS_CONF"
    rm -f $TEMP_SBS_CONF

    create_sbs_monitor "$SBS_MON"
    echo "$MESSAGE108"
    exec $SCRIPT_PATH update
}

updcore_sing_box() {
    echo ""
    echo "$MESSAGE109"
    cp "$singbox_file" "$SB_DIR"; echo "$MESSAGE110"
    return
}

check_sing_box() {
    while true; do
        echo ""; echo "$MESSAGE111"
        if ! output=$($SB_PATH check -c $SB_CONFIG 2>&1); then
            echo "$MESSAGE112"
            echo "$output"
            echo ""
            echo "$MESSAGE113"
            is_running && echo "$MESSAGE114"
            while true; do
                read -p "$MESSAGE18" choice
                case "$choice" in
                    0) echo "$MESSAGE115"; break 2 ;;
                    1) echo ""; is_running && stop_sing_box; echo "$MESSAGE116"; nano $SB_CONFIG; echo "$MESSAGE117"; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        else
            echo "$MESSAGE118"; break
        fi
    done
}

format_sing_box() {
    if ! output=$($SB_PATH format -c $SB_CONFIG 2>&1); then
        echo ""; echo "$MESSAGE112"
        echo "$output"
        echo "$MESSAGE119"
        echo "$MESSAGE66"
    else
        echo ""; echo "$MESSAGE120"
        echo "$output"
        while true; do
            echo "$MESSAGE121"
            read -p "$MESSAGE18" save_choice
            case "$save_choice" in
                0) echo "$MESSAGE122"; break ;;
                1) $SB_PATH format -w -c $SB_CONFIG; echo "$MESSAGE123"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
}

config_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    while true; do
        echo ""
        echo "$MESSAGE124"
        echo ""
        is_running && echo "$MESSAGE125" 
        echo "$MESSAGE126"
        echo "$MESSAGE127"
        echo "$MESSAGE128"
        echo "0-$MESSAGE95"
        read -p "$MESSAGE99 [0-3]: " choice
        case "$choice" in
            1) is_running && stop_sing_box; echo ""; echo "$MESSAGE116"; nano $SB_CONFIG; echo "$MESSAGE129" ;;
            2) check_sing_box ;;
            3) format_sing_box ;;
            0) break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
    is_running || sing_box_start
}

status_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"

    if is_running; then
        echo "$MESSAGE30"
    else
        echo "$MESSAGE37"
    fi

    sbs_version=$(get_sbs_version $SCRIPT_PATH)
    if [ -n "$sbs_version" ]; then
        printf "$MESSAGE130\n" "$sbs_version"
    else
        echo "$MESSAGE131"
    fi

    sb_versplat=$(get_sb_versplat $SB_PATH)
    if [ -n "$sb_versplat" ]; then
        printf "$MESSAGE132\n" "$sb_versplat"
    else
        echo "$MESSAGE133"
    fi

    echo "$MESSAGE134"
    echo "$MESSAGE135"
    is_running && [ -n "$WAN_PORTS" ] && printf "$MESSAGE189\n" "$WAN_PORTS"
}

check_wan_ports() {
    current_ports=$(echo "$WAN_PORTS" | tr ' ' '\n')
    updated_ports=""
    for combination in $current_ports; do
        proxy_type=$(echo "$combination" | cut -d':' -f1)
        port=$(echo "$combination" | cut -d':' -f2)
        found_match=0
        in_inbounds=0
        search_port=0
        while read -r line; do
            if echo "$line" | grep -q '^[[:space:]]*"inbounds"'; then
                in_inbounds=1
            fi
            if [ "$in_inbounds" -eq 1 ] && echo "$line" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"$proxy_type\""; then
                search_port=1
                continue
            fi
            if [ "$search_port" = "1" ] && echo "$line" | grep -q "^[[:space:]]*\"listen_port\"[[:space:]]*:[[:space:]]*$port\\b"; then
                found_match=1
                break
            fi
            if echo "$line" | grep -q '^[[:space:]]*"type"[[:space:]]*:[[:space:]]*'; then
                search_port=0
            fi
        done < "$SB_CONFIG"
        if [ "$found_match" -eq 1 ]; then
            updated_ports="$updated_ports $combination"
        fi
    done
    updated_ports=$(echo "$updated_ports" | tr -s ' ' | sed 's/^ //')
    sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"$updated_ports\"|" "$SBS_CONF"
}

add_del_ports() {
    source "$SBS_CONF"
    VALID_TYPES="vless vmess shadowsocks trojan naive hysteria shadowtls tuic hysteria2"
    read -p "$MESSAGE136" input_combinations
    if [ -z "$input_combinations" ]; then
        echo "$MESSAGE137"
    fi
    combinations=$(echo "$input_combinations" | tr ' ' '\n')
    current_ports=$(grep "^WAN_PORTS=" "$SBS_CONF" | cut -d '"' -f 2)
    for combination in $combinations; do
      found_match=0
      proxy_type=$(echo "$combination" | cut -d':' -f1)
      port=$(echo "$combination" | cut -d':' -f2)
      if ! echo "$VALID_TYPES" | grep -qw "$proxy_type"; then
        printf "$MESSAGE138\n" "$proxy_type"
        continue
      fi
      in_inbounds=0
      search_port=0
      while read -r line; do
        if echo "$line" | grep -q '^[[:space:]]*"inbounds"[[:space:]]*:'; then
          in_inbounds=1
        fi
        if [ "$in_inbounds" -eq 1 ] && echo "$line" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"$proxy_type\""; then
          search_port=1
          continue
        fi
        if [ "$search_port" = "1" ] && echo "$line" | grep -q "^[[:space:]]*\"listen_port\"[[:space:]]*:[[:space:]]*$port\\b"; then
          found_match=1
          break
        fi
        if echo "$line" | grep -q '^[[:space:]]*"type"[[:space:]]*:'; then
          search_port=0
        fi
      done < "$SB_CONFIG"
      if [ "$found_match" -eq 0 ]; then
        printf "$MESSAGE139\n" "$proxy_type:$port"
        continue
      fi
      if echo "$current_ports" | grep -wq "$proxy_type:$port"; then
        current_ports=$(echo "$current_ports" | sed "s/\b$proxy_type:$port\b//g" | tr -s ' ' | sed 's/^ //')
        printf "$MESSAGE140\n" "$proxy_type:$port"
      else
        if [ -n "$current_ports" ]; then
          current_ports="$current_ports $proxy_type:$port"
        else
          current_ports="$proxy_type:$port"
        fi
        printf "$MESSAGE141\n" "$proxy_type:$port"
      fi
    done
    sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"$current_ports\"|" "$SBS_CONF"
    source "$SBS_CONF"
    echo ""
    if [ -z "$WAN_PORTS" ]; then
        echo "$MESSAGE142"
    else
        printf "$MESSAGE143\n" "$WAN_PORTS"
    fi
    serv_sing_box
}

exch_ports() {
    source "$SBS_CONF"
    VALID_TYPES="vless vmess shadowsocks trojan naive hysteria shadowtls tuic hysteria2"
    read -p "$MESSAGE136" input_combinations
    if [ -z "$input_combinations" ];then
        echo "$MESSAGE137"
        sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"\"|" "$SBS_CONF"
        source "$SBS_CONF"
        echo ""
        echo "$MESSAGE144"
        serv_sing_box
        return
    fi
    combinations=$(echo "$input_combinations" | tr ' ' '\n')
    new_ports=""
    invalid_combinations=0
    for combination in $combinations; do
        found_match=0
        proxy_type=$(echo "$combination" | cut -d':' -f1)
        port=$(echo "$combination" | cut -d':' -f2)
        if ! echo "$VALID_TYPES" | grep -qw "$proxy_type"; then
            printf "$MESSAGE138\n" "$proxy_type"
            invalid_combinations=1
            continue
        fi
        in_inbounds=0
        search_port=0
        while read -r line; do
            if echo "$line" | grep -q '^[[:space:]]*"inbounds"[[:space:]]*:'; then
                in_inbounds=1
            fi
            if [ "$in_inbounds" -eq 1 ] && echo "$line" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"$proxy_type\""; then
                search_port=1
                continue
            fi
            if [ "$search_port" = "1" ] && echo "$line" | grep -q "^[[:space:]]*\"listen_port\"[[:space:]]*:[[:space:]]*$port\\b"; then
                found_match=1
                break
            fi
            if echo "$line" | grep -q '^[[:space:]]*"type"[[:space:]]*:'; then
                search_port=0
            fi
        done < "$SB_CONFIG"
        if [ "$found_match" -eq 0 ]; then
            printf "$MESSAGE139\n" "$proxy_type:$port"
            invalid_combinations=1
            continue
        fi
        if [ -n "$new_ports" ]; then
            new_ports="$new_ports $proxy_type:$port"
        else
            new_ports="$proxy_type:$port"
        fi
    done
    if [ -n "$new_ports" ]; then
        sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"$new_ports\"|" "$SBS_CONF"
        source "$SBS_CONF"
        echo ""
        printf "$MESSAGE145\n" "$WAN_PORTS"
    else
        echo "$MESSAGE146"
        echo ""
        printf "$MESSAGE143\n" "$WAN_PORTS"
    fi
    serv_sing_box
}

server_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    if is_running; then
        echo ""
        echo "$MESSAGE148"
        while true; do
            read -p "$MESSAGE18" choice
            case "$choice" in
                0) echo "$MESSAGE90"; exit 0 ;;
                1) stop_sing_box; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
    echo ""
    echo "$MESSAGE149"
    echo ""
    echo "$MESSAGE150"
    echo "$MESSAGE151"
    echo "$MESSAGE152"
    echo ""
    check_wan_ports
    source "$SBS_CONF"
    if [ -z "$WAN_PORTS" ]; then
        echo "$MESSAGE142"
    else
        printf "$MESSAGE143\n" "$WAN_PORTS"
    fi
    serv_sing_box
}

serv_sing_box() {
    source "$SBS_CONF"
    check_wan_ports
    source "$SBS_CONF"
    if [ -z "$WAN_PORTS" ]; then
        while true; do
            echo "$MESSAGE153"
            read -p "$MESSAGE18" init_portchoice
            case "$init_portchoice" in
                0) echo "$MESSAGE154"; break ;;
                1) add_del_ports; exit 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        while true; do
            echo "$MESSAGE155"
            echo "$MESSAGE156"
            echo "0. $MESSAGE95"
            read -p "$MESSAGE47" act_portchoice
            case "$act_portchoice" in
                1) add_del_ports; exit 0 ;;
                2) exch_ports; exit 0 ;;
                0) echo "$MESSAGE95"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
    sing_box_start
}

install_sing_box() {
    uname -m | grep -Eq 'arm|aarch' || { echo "$MESSAGE236"; del_if_notcurrent; exit 1; }
    { [ "$(uname -r | cut -d. -f1)" -gt 4 ] || [ "$(uname -r | cut -d. -f1)" -eq 4 -a "$(uname -r | cut -d. -f2)" -ge 1 ]; } || { echo "$MESSAGE237"; del_if_notcurrent; exit 1; }
    if [ -n "$ROOT_DIR" ]; then
        create_or_use_existing "$SB_DIR"
    else
        printf "$MESSAGE162\n" "$ROOT_DIR"
        del_if_notcurrent
        exit 1
    fi
    create_dir "$SB_DOWNLOAD_DIR"
    handle_existing_file "$TEMP_SBS_CONF" create_sbs_conf
    echo "Выбор языка / Select language:"
    while true; do
        echo " 1 - Русский / Russian"
        echo " 2 - Aнглийский / English"
        echo " 0 - Выход / Exit"
        read -p "Введите номер пункта / Enter item number: " language_choice
        case "$language_choice" in
            1) wget -q -O $TEMP_LANG_RU $LANG_RU_URL && chmod 664 $TEMP_LANG_RU; source "$TEMP_LANG_RU"; sed -i 's/^LANG=".*"/LANG="ru"/' "$TEMP_SBS_CONF"; break ;;
            2) wget -q -O $TEMP_LANG_EN $LANG_EN_URL && chmod 664 $TEMP_LANG_EN; source "$TEMP_LANG_EN"; sed -i 's/^LANG=".*"/LANG="en"/' "$TEMP_SBS_CONF"; break ;;
            0) del_if_notcurrent; rm -f "$TEMP_SBS_CONF"; exit 0 ;;
            *) echo "Некорректный ввод. Попробуйте ещё раз. / Invalid input. Please try again." ;;
        esac
    done

    source "$TEMP_SBS_CONF"
    [ "$LANG" = "ru" ] && source "$TEMP_LANG_RU"
    [ "$LANG" = "en" ] && source "$TEMP_LANG_EN"

    echo "$MESSAGE158"
    while true; do
        read -p "$MESSAGE18" choice
        case $choice in
            0) del_if_notcurrent; rm -f $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN; echo "$MESSAGE159"; exit 0 ;;
            1) if is_running; then
                echo "$MESSAGE160"
                while true; do
                   read -p "$MESSAGE18" continue_choice
                   case "$continue_choice" in
                       0) del_if_notcurrent; rm -f $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN; echo "$MESSAGE159"; exit 0 ;;
                       1) stop_sing_box; break ;;
                       *) echo "$MESSAGE6" ;;
                   esac
                done
               else break; fi; break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done

    echo "$MESSAGE161"
    create_or_use_existing "$JFFS_SB_DIR"
    handle_existing_file "$SCRIPT_PATH" self_copy
    ln -sf $SCRIPT_PATH $LN_PATH
    handle_existing_file "$SBS_MON" create_sbs_monitor
    check_file_existence_and_download "$SB_CONFIG" "$SB_CONFIG_URL"
    chmod 664 "$SB_CONFIG"
    check_copy_file "$TEMP_SBS_CONF" "$SBS_CONF"
    check_copy_file "$TEMP_LANG_RU" "$LANG_RU"
    check_copy_file "$TEMP_LANG_EN" "$LANG_EN"

    if [ "$(uname -m)" = "aarch64" ]; then
        SB_ARCHIVE_PATH="$SB_DOWNLOAD_DIR/sing-box-linux-arm64.tar.gz"
        ARCHIVE_SUFFIX="linux-arm64.tar.gz"
    else
        SB_ARCHIVE_PATH="$SB_DOWNLOAD_DIR/sing-box-linux-armv7.tar.gz"
        ARCHIVE_SUFFIX="linux-armv7.tar.gz"
    fi
    SB_DOWNLOAD_URL=$(wget --quiet --header="Accept: application/vnd.github.v3+json" -O - "$SB_URL" | \
    awk -v suffix="$ARCHIVE_SUFFIX" '
        BEGIN { found=0 }
        /"prerelease": false/ { found=1 }
        found && /"browser_download_url":/ && $0 ~ suffix {
            gsub(/^.*"browser_download_url": *"/, "")
            gsub(/".*$/, "")
            print
            exit
        }
    ')
    DOWNLOAD_URL="$SB_DOWNLOAD_URL"
    ARCHIVE_PATH="$SB_ARCHIVE_PATH"

    echo "$MESSAGE163"
    if wget --spider -q "$DOWNLOAD_URL"; then
        wget -q -O "$ARCHIVE_PATH" "$DOWNLOAD_URL"
        echo "$MESSAGE164"
        tar -xzvf "$ARCHIVE_PATH" -C "$SB_DOWNLOAD_DIR"
        sing_box_file=$(find "$SB_DOWNLOAD_DIR" -name "sing-box" -exec test -f {} \; -print)
        if [ -f "$SB_PATH" ]; then
            echo "$MESSAGE165"
            while true; do
                read -p "$MESSAGE12" choice
                case $choice in
                    0) echo "$MESSAGE13"; break ;;
                    1) cp "$sing_box_file" "$SB_DIR"; chmod 775 "$SB_PATH"; printf "$MESSAGE166\n" "$SB_PATH"; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        else
            cp "$sing_box_file" "$SB_DIR"; printf "$MESSAGE168\n" "$SB_DIR"
        fi
    else
        if [ -f "$SB_PATH" ]; then
            echo "$MESSAGE167 $MESSAGE13"
        else
            echo "$MESSAGE167 $MESSAGE220"
        fi
    fi
    del_if_notcurrent; rm -rf $SB_DOWNLOAD_DIR $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN
    printf "$MESSAGE170\n" "$SB_DOWNLOAD_DIR"
    echo ""
    echo "$MESSAGE171"
}

remove_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"

    echo "$MESSAGE172"
    while true; do
        read -p "$MESSAGE18" choice
        case $choice in
            0) echo "$MESSAGE173"; exit 0 ;;
            1) is_running && stop_sing_box; echo "$MESSAGE174"; rm -rf $SB_DIR $JFFS_SB_DIR $LN_PATH; echo "$MESSAGE175"; exit 0 ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

show_menu() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"

    echo "$MESSAGE176"
    echo "$MESSAGE177"
    echo "$MESSAGE178"
    echo "$MESSAGE179"
    echo "$MESSAGE180"
    echo "$MESSAGE181"
    echo "$MESSAGE182"
    echo "$MESSAGE183"
    echo "$MESSAGE184"
    echo "$MESSAGE185"
    echo "$MESSAGE157"
    echo "$MESSAGE186"
    echo "0) $MESSAGE95"
}

case "$1" in
    install) install_sing_box ;;
    start) start_sing_box ;;
    stop) stop_sing_box ;;
    restart) stop_sing_box; sleep 3; start_sing_box ;;
    config) config_sing_box ;;
    setup) setup_sing_box ;;
    update) update_sing_box ;;
    status) status_sing_box ;;
    server) server_sing_box ;;
    lang) change_language ;;
    remove) remove_sing_box ;;
    updmonandconf) updmonandconf_sing_box ;;
    *)
    while true; do
        show_menu
        read -p "$MESSAGE187" choice
        case $choice in
            1) start_sing_box; break ;;
            2) stop_sing_box; break ;;
            3) stop_sing_box; sleep 3; start_sing_box; break ;;
            4) config_sing_box; break ;;
            5) setup_sing_box; break ;;
            6) update_sing_box; break ;;
            7) status_sing_box; break ;;
            8) server_sing_box; break ;;
            9) change_language; break ;;
            10) remove_sing_box; break ;;
            0) exit 0 ;;
            *) echo "$MESSAGE6" ;;
        esac
    done ;;
esac

# The developer of script is Dr4tez dr4tez@gmail.com https://github.com/Dr4tez/sing-box4asus
# The sing-box core is used for work https://github.com/SagerNet/sing-box
