#!/bin/sh

# Version 2.3.15
# Скрипт для запуска sing-box на роутерах Asus с прошивкой Мерлина и установленным на USB носителе Entware.

# Переменные
JFFS_SB_DIR="/jffs/addons/sing-box-script"
SB_CONFIG="$JFFS_SB_DIR/config.json"
SCRIPT_PATH="$JFFS_SB_DIR/sbs"
SBS_CONF="$JFFS_SB_DIR/sbs-conf"
SBS_MON="$JFFS_SB_DIR/sbs-monitor"
LANG_RU="$JFFS_SB_DIR/sbs-lang-ru"
LANG_EN="$JFFS_SB_DIR/sbs-lang-en"
SCRIPT_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/sbs"
SB_CONFIG_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/config.json"
LANG_RU_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/sbs-lang-ru"
LANG_EN_URL="https://raw.githubusercontent.com/Dr4tez/sing-box4asus/test/sbs-lang-en"
ROOT_DIR="/opt/root"
SB_DIR="$ROOT_DIR/sing-box"
SB_PATH="$SB_DIR/sing-box"
SB_URL="https://api.github.com/repos/SagerNet/sing-box/releases"
SB_DOWNLOAD_DIR="$SB_DIR/sing-box-download"
TEMP_UPDATE="$SB_DOWNLOAD_DIR/temp-update"
TEMP_SCRIPT_PATH="$SB_DOWNLOAD_DIR/sbs"
TEMP_SBS_CONF="$SB_DOWNLOAD_DIR/sbs-conf"
TEMP_LANG_RU="/jffs/scripts/sbs-lang-ru"
TEMP_LANG_EN="/jffs/scripts/sbs-lang-en"
FW_SCRIPT="/jffs/scripts/firewall-start"
NAT_SCRIPT="/jffs/scripts/nat-start"
SS_SCRIPT="/jffs/scripts/services-start"
SS_LINES="(sleep 45 && $SCRIPT_PATH start) &"
LN_PATH="/opt/bin/sbs"
BR0_ADDRESS=$(ip -4 addr show dev br0 | awk "/inet /{print \$2}" | cut -d/ -f1)
DNAT_DNS="1.1.1.1:53535"

# Функции
log_msg() {
    echo "$1"
    logger -t "sbs" "$1"
}

create_dir() {
    mkdir -p "$1"
    chmod 775 "$1"
    printf "$MESSAGE1\n" "$1"
}

create_sbs_conf() {
    cat << EOF > "$1"
# Создан в SBS 2.3.15
# Этот файл создаётся автоматически и значения в него вводятся через консоль роутера при выполнении определённых пунктов в меню, вызываемых командами 'sbs setup', 'sbs update', 'sbs server', 'sbs limit' или 'sbs lang'. Не рекомендуется изменять значения в нём напрямую, в обход перечисленных команд.
# Если вы всё же хотите изменить здесь значения напрямую, то перед этим обязательно остановите sing-box с помощью команды 'sbs stop' в консоли роутера, иначе вам не избежать неприятных багов, от которых без специальных познаний будет сложно избавиться.
#
# Строка DEVICE_IPS - тут между кавычками указываются IP-адреса устройств, трафик которых вы хотите направить через sing-box. IP-адреса должны быть в одну строку и между ними должно быть только по одному пробелу. Так же тут можно указать и подсеть в формате CIDR, например 192.168.50.0/24. Значения задаются в первом пункте меню 'sbs setup'.
# Строка EXC_DEVICE_IPS - если в строке DEVICE_IPS указана подсеть, то тут можно указать IP-адреса устройств из этой подсети, трафик которых вы хотите исключить из направления через sing-box. Так же тут можно указать подсеть меньшего размера, которая входит в указанную в DEVICE_IPS, если это соответствует вашим целям. Значения задаются в первом пункте меню 'sbs setup', только если в DEVICE_IPS указать подсеть.
# Строка DEVICE_FIPS - тут указываются IP-адреса устройств, которые вы хотите заставить работать через fakeip. В остальном аналогично строке DEVICE_IPS. Значения задаются в меню 'sbs setup', только если в файле конфигурации config.json присутствуют настройки fakeip.
# Строка EXC_DEVICE_FIPS - если в строке DEVICE_FIPS указана подсеть, то тут можно указать IP-адреса устройств из этой подсети, которые вы хотите исключить из работы через fakeip. В остальном аналогично строке EXC_DEVICE_IPS. Значения задаются в меню 'sbs setup', только если в файле конфигурации config.json присутствуют настройки fakeip и в DEVICE_FIPS указать подсеть.
# Строка ROUTE_TABLE - если указанный в ней по умолчанию номер таблицы маршрутизации 5553 уже занят в вашем роутере, что маловероятно, можете заменить его на другой, который не занят. Значение задаётся в меню 'sbs setup' в подменю необязательных экспертных настроек.
# Строка FW_MARK - если указанный в ней по умолчанию fwmark 0x4d3c2b1a уже занят в вашем роутере, что маловероятно, можете заменить его на другой, который не занят. Значение задаётся в меню 'sbs setup' в подменю необязательных экспертных настроек, только если в файле конфигурации config.json присутствует tproxy inbound.
# Строка WAN_PORTS - при старте sing-box указанные в ней порты будут открыты для доступа из WAN в роутер. Не открывайте порты из интернета в свой роутер без осознанной необходимости. Открытие не тех портов может привести к потере всех данных в вашей домашней сети. Значения задаются в меню 'sbs server', но будут приняты, только если в файле конфигурации config.json действительно присутствуют указанные типы inbound proxy с указанными портами.
# Строка LANG - если указать значение "ru", то все сообщения от скрипта будут на русском языке, а если "en"- на английском. Значение задаётся в меню 'sbs lang'.
# Строка SB_REPO - тут указывается какой репозиторий использовать для загрузки ядра sing-box. Возможные значения "original", "customa" и "customb" соответствуют официальному и двум кастомным репозиториям. Значение задаётся при выборе одного из первых трёх пунктов в подменю 3-1 меню 'sbs update'.
# Строки CUSTOM_REPO_A и CUSTOM_REPO_B - в них указываются кастомные репозитории ядра sing-box в формате "имя_github_профиля/наименование_репозитория", например "shtorm-7/sing-box-extended". Значения задаются в первых двух пунктах подменю 3-1-4 меню 'sbs update'.
# Строка CORE_VERS - тут указывается какое ядро sing-box будет установлено. Значения "release", "pre_release" или "given" - соответствуют новейшему стабильному релизу, новейшему пре-релизу и заданной версии. Значение задаётся при выборе одного из первых трёх пунктов в подменю 3-2 меню 'sbs update'.
# Строка GIVEN_VERS - тут указывается какая конкретно версия ядра sing-box может быть установлена, если значение строки CORE_VERS будет "given". Значение задаётся в пункте 3-2-4 меню 'sbs update'. Например "1.11.14" или "1.12.0-beta.32".
# Строка NUM_RELEASES - тут указывается глубина поиска, т.е. количество последних релизов, среди которого будут искаться заданная версия ядра, новейший стабильный релиз или новейший пре-релиз ядра. Значение задаётся в пункте 3-2-5 меню 'sbs update'. Например "90".
# Строка S_MEMLIM - тут указывается значение мягкого лимита в MiB, без указания единцы измерения, например "50". При отсутствии значения- лимит отключен. Значение задаётся в меню 'sbs limit' в подменю необязательных экспертных настроек, либо вычисляется автоматически при настройке лимита в подменю простой настройки.
# Строка H_MEMLIM - тут указывается значение жёсткого лимита в MiB, без указания единцы измерения, например "50". При отсутствии значения- лимит отключен. Значение задаётся в меню 'sbs limit' в подменю необязательных экспертных настроек, либо в подменю простой настройки.
# Строка K_GOGC - тут указывается значение GOGC. При отсутствии значения- используется значение по умолчанию ядра sing-box. Значение задаётся в меню 'sbs limit' в подменю необязательных экспертных настроек.
# Строки TUN_INTERFACE, TPROXY_PORT и FAKEIP_SUBNET - их значения автоматически извлекаются из конфигурационного файла sing-box и записываются сюда.

DEVICE_IPS=""
EXC_DEVICE_IPS=""
DEVICE_FIPS=""
EXC_DEVICE_FIPS=""
ROUTE_TABLE="5553"
FW_MARK="0x4d3c2b1a"
WAN_PORTS=""
LANG=""
SB_REPO="original"
CUSTOM_REPO_A=""
CUSTOM_REPO_B=""
CORE_VERS="release"
GIVEN_VERS=""
NUM_RELEASES=""
TUN_INTERFACE=""
TPROXY_PORT=""
FAKEIP_SUBNET=""
S_MEMLIM=""
H_MEMLIM=""
K_GOGC=""
EOF
    chmod 664 "$1"
}

create_sbs_monitor() {
    script_path="$1"
    script_content='#!/bin/sh
# Создан в SBS 2.3.15

source "/jffs/addons/sing-box-script/sbs-conf"

if [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; then
    m_sorted_subnets=$(echo "$DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS}" | tr " " "\n" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+" | sort -t "/" -k2,2n)
fi
BR0_ADDRESS=$(ip -4 addr show dev br0 | awk "/inet /{print \$2}" | cut -d/ -f1)

m_log_msg() {
    echo "$1"
    logger -t "sbs-monitor" "$1"
}

m_update_script() {
    [ -f "$1" ] || { echo "#!/bin/sh" > "$1"; chmod 755 "$1"; }
    echo "$2" | while IFS= read -r line; do
        grep -qF "$line" "$1" || echo "$line" >> "$1"
    done
}

m_get_main_ips() {
    ip -4 route show | awk "{print \$1}" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/[0-9]+)?$" | grep -v "^169\.254\." | while read addr; do
        case "$addr" in
            */*) echo "$addr" ;;
            *) echo "$addr/32" ;;
        esac
    done
}

sbs_monitor_rr() {
    route_in_process=0

  { ip monitor route | while read _; do
        if [ "$route_in_process" -eq 0 ]; then
            route_in_process=1
            if ! ps | grep "[s]ing-box run" >/dev/null 2>&1; then
                [ -n "$S_MEMLIM" ] && export GOMEMLIMIT=${S_MEMLIM}MiB
                [ -n "$K_GOGC" ] && export GOGC=$K_GOGC
                "/opt/root/sing-box/sing-box" run -c "/jffs/addons/sing-box-script/config.json" &
            fi
            if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; } && [ -n "$FW_MARK" ]; then
                sed -i "/sing-box-script-mangle/d" /jffs/scripts/nat-start
                iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null
                iptables -t mangle -F SBS-MANGLE 2>/dev/null
                iptables -t mangle -N SBS-MANGLE 2>/dev/null
                iptables -t mangle -I PREROUTING -j SBS-MANGLE
                m_update_script /jffs/scripts/nat-start "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBS-MANGLE # sing-box-script-mangle"
                if [ -n "$m_sorted_subnets" ]; then
                    echo "$m_sorted_subnets" | while read -r subnet; do
                        if echo "$DEVICE_IPS" | grep -qw "$subnet"; then
                            iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN # sing-box-script-mangle"
                            if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                                iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                                iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                            else
                                iptables -t mangle -I SBS-MANGLE -s $subnet -j MARK --set-mark $FW_MARK
                                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -s $subnet -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                            fi
                        elif echo "$EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS}" | grep -qw "$subnet"; then
                            iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN # sing-box-script-mangle"
                        fi
                    done
                fi
                if ipset list sbsinc-ipset >/dev/null 2>&1; then
                    iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j RETURN # sing-box-script-mangle"
                    if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                        iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                    else
                        iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j MARK --set-mark $FW_MARK
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                    fi
                fi
                if ipset list sbsfinc-ipset >/dev/null 2>&1; then
                    iptables -t mangle -I SBS-MANGLE -m set --match-set sbsfinc-ipset src -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsfinc-ipset src -j RETURN # sing-box-script-mangle"
                fi
                if [ -n "$FAKEIP_SUBNET" ]; then
                    iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j RETURN # sing-box-script-mangle"
                    if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                        iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                    else
                        iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                    fi
                fi
                m_get_main_ips | while read mainip; do
                    iptables -t mangle -I SBS-MANGLE -d $mainip -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -d $mainip -j RETURN # sing-box-script-mangle"
                done
                iptables -t mangle -I SBS-MANGLE -d 239.0.0.0/8 -j RETURN
                iptables -t mangle -I SBS-MANGLE -d 169.254.0.0/16 -j RETURN
                iptables -t mangle -I SBS-MANGLE -d 224.0.0.0/24 -j RETURN
                iptables -t mangle -I SBS-MANGLE -d 255.255.255.255 -j RETURN
                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -d 239.0.0.0/8 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -d 169.254.0.0/16 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -d 224.0.0.0/24 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -d 255.255.255.255 -j RETURN # sing-box-script-mangle"

                if [ -n "$m_sorted_subnets" ]; then
                    echo "$m_sorted_subnets" | while read -r subnet; do
                        if echo "$DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}" | grep -qw "$subnet"; then
                            iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN
                            iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle"
                            if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                                iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                                iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                            else
                                iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK
                                iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK
                                m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                            fi
                        elif echo "$EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$EXC_DEVICE_FIPS}" | grep -qw "$subnet"; then
                            iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN
                            iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle"
                        fi
                    done
                fi
                for setname in sbsinc-ipset sbsfinc-ipset; do
                    if ipset list "$setname" >/dev/null 2>&1; then
                        iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src --dport 53 -j RETURN
                        iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src --dport 53 -j RETURN
                        m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src --dport 53 -j RETURN # sing-box-script-mangle"
                        if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                            iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                            iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                        else
                            iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK
                            iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK
                            m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                        fi
                    fi
                done
                if ipset list sbsexc-ipset >/dev/null 2>&1; then
                    iptables -t mangle -I SBS-MANGLE -m set --match-set sbsexc-ipset src -j RETURN
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsexc-ipset src -j RETURN # sing-box-script-mangle"
                fi
                m_update_script /jffs/scripts/nat-start ") & # sing-box-script-mangle"
            fi
            if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -z "$DEVICE_IPS" ] && [ -z "$DEVICE_FIPS" ] && [ -n "$FAKEIP_SUBNET" ] && [ -n "$FW_MARK" ]; then
                sed -i "/sing-box-script-mangle/d" /jffs/scripts/nat-start
                iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null
                iptables -t mangle -F SBS-MANGLE 2>/dev/null
                iptables -t mangle -N SBS-MANGLE 2>/dev/null
                iptables -t mangle -I PREROUTING -j SBS-MANGLE
                m_update_script /jffs/scripts/nat-start "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBS-MANGLE # sing-box-script-mangle"
                if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                    iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                    iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK; ) & # sing-box-script-mangle"
                else
                    iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK
                    m_update_script /jffs/scripts/nat-start "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK; ) & # sing-box-script-mangle"
                fi
            fi
            if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -n "$FW_MARK" ]; then
                if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                    ip route add local 0.0.0.0/0 dev lo table $ROUTE_TABLE 2>/dev/null
                else
                    ip route add default dev $TUN_INTERFACE table $ROUTE_TABLE 2>/dev/null
                    echo 2 > /proc/sys/net/ipv4/conf/$TUN_INTERFACE/rp_filter
                fi
            fi; route_in_process=0
        fi
    done } &

    ip monitor rule | while read line; do
        if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -n "$FW_MARK" ]; then
            if ! ip rule show | grep -q "from all fwmark ${FW_MARK%%/*} lookup $ROUTE_TABLE"; then
                ip rule add fwmark $FW_MARK lookup $ROUTE_TABLE priority 5353
            fi
        fi
    done
}

trap "" SIGHUP

if [ -n "$H_MEMLIM" ]; then
    (
        while true; do
            hard_memlim=$(awk "{printf \"%.0f\n\", (\$2-\$3)*4096/1024/1024}" /proc/$(ps w | grep "[s]ing-box run" | awk "{print \$1}")/statm)
            if [ "$(printf "%.0f" "$hard_memlim")" -ge $H_MEMLIM ]; then
                kill $(ps | grep "[s]ing-box run" | awk "{print \$1}") 2>/dev/null
                [ "$LANG" = "ru" ] && m_log_msg "Процесс sing-box перезапущен из-за достижения жёсткого лимита памяти."
                [ "$LANG" = "en" ] && m_log_msg "The sing-box process was restarted because it reached its hard memory limit."
            fi
            sleep 5
        done
    ) &
fi

if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
    (
        while true; do
            if ! ps | grep "[s]ing-box run" >/dev/null 2>&1; then
                [ -n "$S_MEMLIM" ] && export GOMEMLIMIT=${S_MEMLIM}MiB
                [ -n "$K_GOGC" ] && export GOGC=$K_GOGC
                "/opt/root/sing-box/sing-box" run -c "/jffs/addons/sing-box-script/config.json" &
            fi
            sleep 5
        done
    ) &
fi

sbs_monitor_rr 2>/dev/null
'
    echo "$script_content" > "$script_path"
    chmod +x "$script_path"
}

check_file_existence_and_download() {
    local file_path="$1"
    local file_url="$2"
    local file_name=$(basename "$file_path")

    if [ -f "$file_path" ]; then
        printf "$MESSAGE2\n" "$file_name"
        while true; do
            read -p "$MESSAGE3" choice
            [ -z "$choice" ] && echo "$MESSAGE13" && return 0
            case $choice in
                1) printf "$MESSAGE5\n" "$file_name"; wget -q -O "$file_path" "$file_url"; return 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        printf "$MESSAGE7\n" "$file_name"
        wget -q -O "$file_path" "$file_url"
    fi
}

del_if_notcurrent() {
    local current_path="$(readlink -f "$0")"
    [ "$current_path" != "$SCRIPT_PATH" ] && rm -f "$current_path"
}

create_or_use_existing() {
    local dir_path="$1"

    if [ -d "$dir_path" ]; then
        printf "$MESSAGE8\n" "$dir_path"
        while true; do
            read -p ": " choice
            if [ -z "$choice" ]; then
                del_if_notcurrent; rm -f $TEMP_SBS_CONF $TEMP_LANG_RU $TEMP_LANG_EN; echo "$MESSAGE10"; exit 0
            fi
            case $choice in
                1) printf "$MESSAGE11\n" "$dir_path"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        create_dir "$dir_path"
    fi
}

handle_existing_file() {
    local file_path="$1"
    local create_function="$2"

    if [ -f "$file_path" ]; then
        printf "$MESSAGE2\n" "$file_path"
        while true; do
            read -p "$MESSAGE12" choice
            [ -z "$choice" ] && echo "$MESSAGE13" && break
            case $choice in
                1) printf "$MESSAGE14\n" "$file_path"; "$create_function" "$file_path"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        "$create_function" "$file_path"
    fi
}

check_copy_file() {
    local src_file="$1"
    local dst_file="$2"

    if [ -f "$dst_file" ]; then
        printf "$MESSAGE2\n" "$dst_file"
        while true; do
            read -p "$MESSAGE12" choice
            [ -z "$choice" ] && echo "$MESSAGE13" && break
            case $choice in
                1) [ -f "$src_file" ] && printf "$MESSAGE14\n" "$dst_file" && cp "$src_file" "$dst_file"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        [ -f "$src_file" ] && cp "$src_file" "$dst_file"
    fi
}

change_language() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    while true; do
        if [ "$LANG" = "ru" ]; then
            echo "Перейти на английский?"
            read -p "$MESSAGE18" choice
            [ -z "$choice" ] && echo "$MESSAGE52" && break
            case "$choice" in
                1) [ -f "$LANG_EN" ] || { wget -q -O $LANG_EN $LANG_EN_URL && chmod 664 $LANG_EN; }; source "$LANG_EN"; sed -i 's/^LANG=".*"/LANG="en"/' "$SBS_CONF"; echo "$MESSAGE188"; exit 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        elif [ "$LANG" = "en" ]; then
            echo "Switch to Russian?"
            read -p "$MESSAGE18" choice
            [ -z "$choice" ] && echo "$MESSAGE52" && break
            case "$choice" in
                1) [ -f "$LANG_RU" ] || { wget -q -O $LANG_RU $LANG_RU_URL && chmod 664 $LANG_RU; }; source "$LANG_RU"; sed -i 's/^LANG=".*"/LANG="ru"/' "$SBS_CONF"; echo "$MESSAGE188"; exit 0 ;;
                *) echo "$MESSAGE6" ;;
            esac
        fi
    done
}

update_script() {
    [ -f "$1" ] || { echo "#!/bin/sh" > "$1"; chmod 755 "$1"; }
    echo "$2" | while IFS= read -r line; do
        grep -qF "$line" "$1" || echo "$line" >> "$1"
    done
}

manage_iptables() {
    if [ "$1" = "add" ]; then
        iptables -C $2 2>/dev/null || iptables -I $2 || log_msg "$(printf "$MESSAGE15\n" "$2")"
    elif [ "$1" = "remove" ]; then
        iptables -C $2 2>/dev/null && iptables -D $2 || log_msg "$(printf "$MESSAGE16\n" "$2")"
    fi
}

is_running() {
    ps | grep -v grep | grep -q "$SB_PATH"
}

get_sbs_version() {
    sed -n '3s/^# Version //p' "$1"
}

get_sb_versplat() {
    local vers plat

    vers=$("$1" version | awk '/^sing-box version/ {print $3}' | head -n 1)
    plat=$("$1" version | awk '/^Environment:/ {print $3}' | head -n 1)
    echo "$vers $plat"
}

get_sb_version() {
    local version

    version=$("$1" version | awk '/^sing-box version/ {print $3}' | head -n 1)
    echo "$version"
}

self_copy() {
    local destination="$1"
    cp "$0" "$destination"
}

silent_create_dir() {
    mkdir -p "$1"
    chmod 775 "$1"
}

sing_box_start() {
    echo "$MESSAGE17"
    while true; do
        read -p "$MESSAGE18" choice
        [ -z "$choice" ] && break
        case "$choice" in
            1) start_sing_box; break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

update_tun_interface() {
    tun_interface=""
    in_block=0
    block=""

    while IFS= read -r line; do
        case "$line" in
            *'{'*) 
                block="$line"
                in_block=1
                continue ;;
        esac

        if [ "$in_block" -eq 1 ]; then
            block="$block
$line"
            case "$line" in
                *'}'*) 
                    in_block=0
                    echo "$block" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"tun\"" || continue
                    echo "$block" | grep -q '^[[:space:]]*"interface_name"[[:space:]]*:' || continue
                    tun_interface=$(echo "$block" | sed -n 's/^[[:space:]]*"interface_name"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p')
                    [ -n "$tun_interface" ] && break ;;
            esac
        fi
    done < "$SB_CONFIG"

    if [ -z "$tun_interface" ]; then
        sed -i "s/^TUN_INTERFACE=.*/TUN_INTERFACE=\"\"/" "$SBS_CONF"
    else
        sed -i "s/^TUN_INTERFACE=.*/TUN_INTERFACE=\"$tun_interface\"/" "$SBS_CONF"
    fi
}

extract_listen_port() {
    var_name="$1"
    type_value="$2"
    listen_port=""
    in_block=0
    block=""

    while IFS= read -r line; do
        case "$line" in
            *'{'*) 
                block="$line"
                in_block=1
                continue ;;
        esac

        if [ "$in_block" -eq 1 ]; then
            block="$block
$line"
            case "$line" in
                *'}'*) 
                    in_block=0
                    echo "$block" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"$type_value\"" || continue
                    echo "$block" | grep -q '^[[:space:]]*"listen_port"[[:space:]]*:' || continue
                    listen_port=$(echo "$block" | sed -n 's/^[[:space:]]*"listen_port"[[:space:]]*:[[:space:]]*\([0-9]*\).*/\1/p')
                    [ -n "$listen_port" ] && break ;;
            esac
        fi
    done < "$SB_CONFIG"

    if [ -z "$listen_port" ]; then
        sed -i "s/^$var_name=.*/$var_name=\"\"/" "$SBS_CONF"
    else
        sed -i "s/^$var_name=.*/$var_name=\"$listen_port\"/" "$SBS_CONF"
    fi
}

fakeip_check() {
    found_block=0
    enabled_required=0
    enabled_found=0
    inet4_range=""
    in_block=0

    while IFS= read -r line || [ -n "$line" ]; do
        if [ $in_block -eq 0 ]; then
            if echo "$line" | grep -q '^[[:space:]]*"fakeip"[[:space:]]*:[[:space:]]*{' ; then
                in_block=1
                found_block=1
                enabled_required=1
                enabled_found=0
                inet4_range=""
                continue
            fi
            if echo "$line" | grep -q '^[[:space:]]*"type"[[:space:]]*:[[:space:]]*"fakeip"'; then
                in_block=1
                found_block=1
                enabled_required=0
                enabled_found=1
                inet4_range=""
                continue
            fi
        else
            echo "$line" | grep -q '}' && in_block=0
            if [ $in_block -eq 0 ]; then
                break
            fi
            if [ $enabled_required -eq 1 ]; then
                echo "$line" | grep -q '^[[:space:]]*"enabled"[[:space:]]*:[[:space:]]*true' && enabled_found=1
            fi
            if echo "$line" | grep -q '^[[:space:]]*"inet4_range"[[:space:]]*:'; then
                inet4_range=$(echo "$line" | sed -n 's/^[[:space:]]*"inet4_range"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
            fi
        fi
    done < "$SB_CONFIG"

    if [ $found_block -eq 1 ] && [ $enabled_found -eq 1 ] && [ -n "$inet4_range" ]; then
        sed -i "s|^FAKEIP_SUBNET=.*|FAKEIP_SUBNET=\"$inet4_range\"|" "$SBS_CONF"
    else
        sed -i "s|^FAKEIP_SUBNET=.*|FAKEIP_SUBNET=\"\"|" "$SBS_CONF"
    fi
}

get_main_ips() {
    ip -4 route show | awk "{print \$1}" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(/[0-9]+)?$" | grep -v "^169\.254\." | while read addr; do
        case "$addr" in
            */*) echo "$addr" ;;
            *) echo "$addr/32" ;;
        esac
    done
}

ip_to_int() {
    IFS=. read -r o1 o2 o3 o4 <<EOF
$1
EOF
    echo $(( (o1 << 24) + (o2 << 16) + (o3 << 8) + o4 ))
}

mask_bits_to_int() {
    bits="$1"
    echo $(( 0xFFFFFFFF << (32 - bits) & 0xFFFFFFFF ))
}

parse_cidr() {
    case "$1" in
        */*) IFS=/ read -r ip bits <<EOF
$1
EOF
            ;;
        *) ip="$1"
           bits=32
           ;;
    esac
    ip_int=$(ip_to_int "$ip")
    mask=$(mask_bits_to_int "$bits")
    net=$(( ip_int & mask ))
    echo "$ip_int $bits $mask $net"
}

cidr_in_cidr() {
    cidr_a="$1"
    cidr_b="$2"

    set -- $(parse_cidr "$cidr_a")
    a_ip="$1"
    a_bits="$2"
    a_mask="$3"
    a_net="$4"

    set -- $(parse_cidr "$cidr_b")
    b_ip="$1"
    b_bits="$2"
    b_mask="$3"
    b_net="$4"

    [ "$a_bits" -lt "$b_bits" ] && return 1

    if [ "$(( a_net & b_mask ))" -eq "$b_net" ]; then
        return 0
    else
        return 1
    fi
}

valid_combs() {
    comb=$1
    proxy_type=$(printf "%s" "$comb" | cut -d: -f1)
    c_port=$(printf "%s" "$comb" | cut -d: -f2)
    in_inbounds=0
    in_endpoints=0
    search_port=0
    while read -r c_line; do
        if echo "$c_line" | grep -q '^[[:space:]]*"inbounds"[[:space:]]*:'; then
            in_inbounds=1
            in_endpoints=0
            continue
        fi
        if echo "$c_line" | grep -q '^[[:space:]]*"endpoints"[[:space:]]*:'; then
            in_endpoints=1
            in_inbounds=0
            continue
        fi
        if [ "$proxy_type" != "wireguard" ]; then
            if [ "$in_inbounds" -eq 1 ] && echo "$c_line" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"$proxy_type\""; then
                search_port=1
                continue
            fi
        else
            if [ "$in_endpoints" -eq 1 ] && echo "$c_line" | grep -q "^[[:space:]]*\"type\"[[:space:]]*:[[:space:]]*\"wireguard\""; then
                search_port=1
                continue
            fi
        fi
        if [ "$search_port" = 1 ] && echo "$c_line" | grep -q "^[[:space:]]*\"listen_port\"[[:space:]]*:[[:space:]]*$c_port\\b"; then
            return 0
        fi
        if echo "$c_line" | grep -q '^[[:space:]]*"type"[[:space:]]*:[[:space:]]*'; then
            search_port=0
        fi
    done < "$SB_CONFIG"
    return 1
}

is_valid_combs() {
    comb=$1
    ALLOWED_TYPES="vless vmess shadowsocks trojan naive hysteria shadowtls tuic hysteria2 anytls wireguard"
    proxy_type=$(printf "%s" "$comb" | cut -d: -f1)
    c_port=$(printf "%s" "$comb" | cut -d: -f2)
    [ -z "$proxy_type" ] && return 1
    [ -z "$c_port" ] && return 1
    if ! printf "%s\n" $ALLOWED_TYPES | grep -qx "$proxy_type"; then return 1; fi
    if ! printf "%s" "$c_port" | grep -Eq '^[0-9]+$'; then return 1; fi
    if [ "$c_port" -lt 1 ] 2>/dev/null || [ "$c_port" -gt 65535 ] 2>/dev/null; then return 1; fi
    return 0
}

check_wan_ports() {
    updated_ports=""
    for combination in $(echo "$WAN_PORTS" | tr ' ' '\n'); do
        if ! is_valid_combs "$combination"; then
            continue
        fi
        if valid_combs "$combination"; then
            updated_ports="${updated_ports:+$updated_ports }$combination"
        fi
    done
    updated_ports=$(echo "$updated_ports" | tr -s ' ' | sed 's/^ //')
    sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"$updated_ports\"|" "$SBS_CONF"
}

start_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    echo
    is_running && { log_msg "$MESSAGE21"; exit 1; }

    all_entries=$(printf "%s\n" $DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS})
    duplicates=$(echo "$all_entries" | sort | uniq -d)
    if [ -n "$duplicates" ]; then
        printf "$MESSAGE190\n" "$duplicates"
        exit 1
    fi

    log_msg "$MESSAGE200"
    update_tun_interface
    extract_listen_port TPROXY_PORT tproxy
    check_wan_ports
    fakeip_check
    source "$SBS_CONF"

    if [ -n "$TUN_INTERFACE" ]; then
        FW_RULES="FORWARD -i $TUN_INTERFACE -j ACCEPT
        FORWARD -o $TUN_INTERFACE -j ACCEPT
        INPUT -i $TUN_INTERFACE -j ACCEPT
        OUTPUT -o $TUN_INTERFACE -j ACCEPT"
        lsmod | grep -q "^tun " || { log_msg "$MESSAGE22"; modprobe tun; sleep 3; }
    elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
        lsmod | grep -q "^xt_TPROXY " || { log_msg "$MESSAGE191"; modprobe xt_TPROXY; sleep 3; }
    fi
    { [ -n "$H_MEMLIM" ] || [ -n "$S_MEMLIM" ] || [ -n "$K_GOGC" ]; } && log_msg "$MESSAGE244"
    [ -n "$S_MEMLIM" ] && export GOMEMLIMIT=${S_MEMLIM}MiB
    [ -n "$K_GOGC" ] && export GOGC=$K_GOGC
    log_msg "$MESSAGE20"
    $SB_PATH run -c $SB_CONFIG &
    sleep 5
    is_running || { log_msg "$MESSAGE201"; exit 1; }
    log_msg "$MESSAGE30"
    if [ -n "$TUN_INTERFACE" ]; then
        echo 2 > /proc/sys/net/ipv4/conf/$TUN_INTERFACE/rp_filter
    fi
# Проверка наличия tun или tproxy интерфейса
    if [ -n "$TUN_INTERFACE" ]; then
        if ip link show "$TUN_INTERFACE" >/dev/null 2>&1; then
            log_msg "$(printf "$MESSAGE23\n" "$TUN_INTERFACE")"
        else
            log_msg "$MESSAGE24"
        fi
    elif [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
        if lsmod | grep -q xt_TPROXY; then
            log_msg "$MESSAGE238"
        else
            log_msg "$MESSAGE239"
        fi
    fi
# Добавление правил nat и обновление скрипта nat-start
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; }; then
        sed -i "/sing-box-script/d" "$NAT_SCRIPT"
        log_msg "$MESSAGE25"
        iptables -t nat -D PREROUTING -j SBS-NAT 2>/dev/null
        iptables -t nat -F SBS-NAT 2>/dev/null
        iptables -t nat -N SBS-NAT 2>/dev/null
        iptables -t nat -I PREROUTING -j SBS-NAT
        iptables -t nat -I SBS-NAT -p tcp -m mark --mark $FW_MARK --dport 53 -j DNAT --to-destination $DNAT_DNS
        iptables -t nat -I SBS-NAT -p udp -m mark --mark $FW_MARK --dport 53 -j DNAT --to-destination $DNAT_DNS
        update_script "$NAT_SCRIPT" "( sleep 15 # sing-box-script-nat
iptables -t nat -D PREROUTING -j SBS-NAT 2>/dev/null # sing-box-script-nat
iptables -t nat -F SBS-NAT 2>/dev/null # sing-box-script-nat
iptables -t nat -N SBS-NAT 2>/dev/null # sing-box-script-nat
iptables -t nat -I PREROUTING -j SBS-NAT # sing-box-script-nat
iptables -t nat -I SBS-NAT -p tcp -m mark --mark $FW_MARK --dport 53 -j DNAT --to-destination $DNAT_DNS # sing-box-script-nat
iptables -t nat -I SBS-NAT -p udp -m mark --mark $FW_MARK --dport 53 -j DNAT --to-destination $DNAT_DNS; ) & # sing-box-script-nat"
    fi
# Добавление правил mangle и обновление скрипта nat-start
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && { [ -n "$DEVICE_IPS" ] || { [ -n "$FAKEIP_SUBNET" ] && [ -n "$DEVICE_FIPS" ]; }; } && [ -n "$FW_MARK" ]; then
        log_msg "$MESSAGE192"
        iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null
        iptables -t mangle -F SBS-MANGLE 2>/dev/null
        iptables -t mangle -N SBS-MANGLE 2>/dev/null
        iptables -t mangle -I PREROUTING -j SBS-MANGLE
        update_script "$NAT_SCRIPT" "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBS-MANGLE # sing-box-script-mangle"

        for IP in $DEVICE_IPS; do
            if ! echo "$IP" | grep -q '/'; then
                ipset create sbsinc-ipset hash:ip
                for IP in $DEVICE_IPS; do
                    if ! echo "$IP" | grep -q '/'; then
                        ipset add sbsinc-ipset "$IP"
                    fi
                done
                break
            fi
        done
        for IP in ${FAKEIP_SUBNET:+$DEVICE_FIPS}; do
            if ! echo "$IP" | grep -q '/'; then
                ipset create sbsfinc-ipset hash:ip
                for IP in $DEVICE_FIPS; do
                    if ! echo "$IP" | grep -q '/'; then
                        ipset add sbsfinc-ipset "$IP"
                    fi
                done
                break
            fi
        done
        for IP in $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$EXC_DEVICE_FIPS}; do
            if ! echo "$IP" | grep -q '/'; then
                ipset create sbsexc-ipset hash:ip
                for IP in $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$EXC_DEVICE_FIPS}; do
                    if ! echo $IP | grep -q '/'; then
                        ipset add sbsexc-ipset $IP
                    fi
                done
                break
            fi
        done
        sorted_subnets=$(echo "$DEVICE_IPS $EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS}" | tr ' ' '\n' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+' | sort -t '/' -k2,2n)
        if [ -n "$sorted_subnets" ]; then
            echo "$sorted_subnets" | while read -r subnet; do
                if echo "$DEVICE_IPS" | grep -qw "$subnet"; then
                    iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN # sing-box-script-mangle"
                    if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                        iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                    else
                        iptables -t mangle -I SBS-MANGLE -s $subnet -j MARK --set-mark $FW_MARK
                        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -s $subnet -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                    fi
                elif echo "$EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS $EXC_DEVICE_FIPS}" | grep -qw "$subnet"; then
                    iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -s $subnet -j RETURN # sing-box-script-mangle"
                fi
            done
        fi
        if ipset list sbsinc-ipset >/dev/null 2>&1; then
            iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j RETURN # sing-box-script-mangle"
            if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set sbsinc-ipset src -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
            else
                iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j MARK --set-mark $FW_MARK
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsinc-ipset src -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
            fi
        fi
        if ipset list sbsfinc-ipset >/dev/null 2>&1; then
            iptables -t mangle -I SBS-MANGLE -m set --match-set sbsfinc-ipset src -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsfinc-ipset src -j RETURN # sing-box-script-mangle"
        fi
        if [ -n "$FAKEIP_SUBNET" ]; then
            iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j RETURN # sing-box-script-mangle"
            if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
            else
                iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
            fi
        fi
        get_main_ips | while read mainip; do
            iptables -t mangle -I SBS-MANGLE -d $mainip -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -d $mainip -j RETURN # sing-box-script-mangle"
        done
        iptables -t mangle -I SBS-MANGLE -d 239.0.0.0/8 -j RETURN
        iptables -t mangle -I SBS-MANGLE -d 169.254.0.0/16 -j RETURN
        iptables -t mangle -I SBS-MANGLE -d 224.0.0.0/24 -j RETURN
        iptables -t mangle -I SBS-MANGLE -d 255.255.255.255 -j RETURN
        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -d 239.0.0.0/8 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -d 169.254.0.0/16 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -d 224.0.0.0/24 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -d 255.255.255.255 -j RETURN # sing-box-script-mangle"

        if [ -n "$sorted_subnets" ]; then
            echo "$sorted_subnets" | while read -r subnet; do
                if echo "$DEVICE_IPS ${FAKEIP_SUBNET:+$DEVICE_FIPS}" | grep -qw "$subnet"; then
                    iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN
                    iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle"
                    if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                        iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                    else
                        iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK
                        iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK
                        update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                    fi
                elif echo "$EXC_DEVICE_IPS ${FAKEIP_SUBNET:+$EXC_DEVICE_FIPS}" | grep -qw "$subnet"; then
                    iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN
                    iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -s $subnet --dport 53 -j RETURN # sing-box-script-mangle"
                fi
            done
        fi
        for setname in sbsinc-ipset sbsfinc-ipset; do
            if ipset list "$setname" >/dev/null 2>&1; then
                iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src --dport 53 -j RETURN
                iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src --dport 53 -j RETURN
                update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src --dport 53 -j RETURN # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src --dport 53 -j RETURN # sing-box-script-mangle"
                if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
                    iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                    iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src -d $BR0_ADDRESS --dport 53 -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle"
                else
                    iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set "$setname" src -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK
                    iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set "$setname" src -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK
                    update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -m set --match-set $setname src -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -m set --match-set $setname src -d $BR0_ADDRESS --dport 53 -j MARK --set-mark $FW_MARK # sing-box-script-mangle"
                fi
            fi
        done
        if ipset list sbsexc-ipset >/dev/null 2>&1; then
            iptables -t mangle -I SBS-MANGLE -m set --match-set sbsexc-ipset src -j RETURN
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -m set --match-set sbsexc-ipset src -j RETURN # sing-box-script-mangle"
        fi
        update_script "$NAT_SCRIPT" ") & # sing-box-script-mangle"
    fi
# То же, но для использования sing-box в качестве чисто DNS сервера с fakeip для конечных устройств или для AGH, попросили такую возможность
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -z "$DEVICE_IPS" ] && [ -z "$DEVICE_FIPS" ] && [ -n "$FAKEIP_SUBNET" ] && [ -n "$FW_MARK" ]; then
        log_msg "$MESSAGE192"
        sed -i "/sing-box-script/d" "$NAT_SCRIPT"
        iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null
        iptables -t mangle -F SBS-MANGLE 2>/dev/null
        iptables -t mangle -N SBS-MANGLE 2>/dev/null
        iptables -t mangle -I PREROUTING -j SBS-MANGLE
        update_script "$NAT_SCRIPT" "( sleep 15 # sing-box-script-mangle
iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -F SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -N SBS-MANGLE 2>/dev/null # sing-box-script-mangle
iptables -t mangle -I PREROUTING -j SBS-MANGLE # sing-box-script-mangle"
        if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
            iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
            iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -p tcp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK # sing-box-script-mangle
iptables -t mangle -I SBS-MANGLE -p udp -d $FAKEIP_SUBNET -j TPROXY --on-port $TPROXY_PORT --tproxy-mark $FW_MARK; ) & # sing-box-script-mangle"
        else
            iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK
            update_script "$NAT_SCRIPT" "iptables -t mangle -I SBS-MANGLE -d $FAKEIP_SUBNET -j MARK --set-mark $FW_MARK; ) & # sing-box-script-mangle"
        fi
    fi
# Добавление правил файрвола, маршрутов и правил маршрутизации и обновление скрипта firewall-start
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -n "$FW_MARK" ]; then
        if [ -n "$TPROXY_PORT" ] && [ -z "$TUN_INTERFACE" ]; then
            log_msg "$MESSAGE27"
            ip route add local 0.0.0.0/0 dev lo table $ROUTE_TABLE
        else
            log_msg "$MESSAGE26"
            echo "$FW_RULES" | while read -r rule; do
                manage_iptables "add" "$rule"
                update_script "$FW_SCRIPT" "iptables -I $rule # sing-box-script"
            done
            log_msg "$MESSAGE27"
            ip route add default dev $TUN_INTERFACE table $ROUTE_TABLE
        fi
        ip rule add fwmark $FW_MARK lookup $ROUTE_TABLE priority 5353
    fi
# Открываем указанные порты из WAN в роутер для режима сервера
    if [ -n "$WAN_PORTS" ]; then
        log_msg "$(printf "$MESSAGE28\n" "$WAN_PORTS")"
        for entry in $WAN_PORTS; do
            wan_port=$(echo "$entry" | cut -d ':' -f 2)
            if ! iptables-save | grep -q -- "-A INPUT -p tcp -m tcp --dport $wan_port -j ACCEPT"; then
                iptables -I INPUT -p tcp --dport "$wan_port" -j ACCEPT
            fi
            if ! iptables-save | grep -q -- "-A INPUT -p udp -m udp --dport $wan_port -j ACCEPT"; then
                iptables -I INPUT -p udp --dport "$wan_port" -j ACCEPT
            fi
            update_script "$FW_SCRIPT" "iptables -I INPUT -p tcp --dport "$wan_port" -j ACCEPT # sing-box-script
iptables -I INPUT -p udp --dport "$wan_port" -j ACCEPT # sing-box-script"
        done
    fi
    $SBS_MON &
    log_msg "$MESSAGE29"
    update_script "$SS_SCRIPT" "$SS_LINES # sing-box-script"
    echo
}

stop_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    echo
    kill $(ps | grep "[s]bs-monitor" | awk '{print $1}') 2>/dev/null
    if [ -n "$TUN_INTERFACE" ]; then
        FW_RULES="FORWARD -i $TUN_INTERFACE -j ACCEPT
        FORWARD -o $TUN_INTERFACE -j ACCEPT
        INPUT -i $TUN_INTERFACE -j ACCEPT
        OUTPUT -o $TUN_INTERFACE -j ACCEPT"
    fi
    log_msg "$MESSAGE32"
    sed -i "/sing-box-script/d" "$SS_SCRIPT" 2>/dev/null
# Очистка системных скриптов
    sed -i "/sing-box-script/d" "$FW_SCRIPT" 2>/dev/null
    sed -i "/sing-box-script/d" "$NAT_SCRIPT" 2>/dev/null
# Удаление правил iptables для открытых WAN портов
    if [ -n "$WAN_PORTS" ]; then
        log_msg "$(printf "$MESSAGE33\n" "$WAN_PORTS")"
        for entry in $WAN_PORTS; do
            wan_port=$(echo "$entry" | cut -d ':' -f 2)
            iptables -D INPUT -p udp --dport "$wan_port" -j ACCEPT 2>/dev/null
            iptables -D INPUT -p tcp --dport "$wan_port" -j ACCEPT 2>/dev/null
        done
    fi
    if { [ -n "$TUN_INTERFACE" ] || [ -n "$TPROXY_PORT" ]; } && [ -n "$ROUTE_TABLE" ] && [ -n "$FW_MARK" ]; then
# Удаление правил маршрутизации, маршрутов и правил iptables
        log_msg "$MESSAGE34"
        ip rule del fwmark $FW_MARK lookup $ROUTE_TABLE >/dev/null 2>&1
        ip route flush table $ROUTE_TABLE
        if [ -n "$TUN_INTERFACE" ]; then
            log_msg "$MESSAGE35"
            echo "$FW_RULES" | while read -r rule; do
                manage_iptables "remove" "$rule" >/dev/null 2>&1
            done
        fi
# Удаление правил mangle
        log_msg "$MESSAGE193"
        iptables -t mangle -D PREROUTING -j SBS-MANGLE 2>/dev/null
        iptables -t mangle -F SBS-MANGLE 2>/dev/null
        iptables -t mangle -X SBS-MANGLE 2>/dev/null
        if ipset list sbsexc-ipset >/dev/null 2>&1; then
            ipset destroy sbsexc-ipset >/dev/null 2>&1
        fi
        if ipset list sbsinc-ipset >/dev/null 2>&1; then
            ipset destroy sbsinc-ipset >/dev/null 2>&1
        fi
        if ipset list sbsfinc-ipset >/dev/null 2>&1; then
            ipset destroy sbsfinc-ipset >/dev/null 2>&1
        fi
# Удаление правил nat
        log_msg "$MESSAGE36"
        iptables -t nat -D PREROUTING -j SBS-NAT 2>/dev/null
        iptables -t nat -F SBS-NAT 2>/dev/null
        iptables -t nat -X SBS-NAT 2>/dev/null
    fi
    log_msg "$MESSAGE31"
    kill $(ps | grep "[s]ing-box" | awk '{print $1}') 2>/dev/null
    log_msg "$MESSAGE37"
    { [ -n "$H_MEMLIM" ] || [ -n "$S_MEMLIM" ] || [ -n "$K_GOGC" ]; } && log_msg "$MESSAGE148"
    [ -n "$S_MEMLIM" ] && unset GOMEMLIMIT
    [ -n "$K_GOGC" ] && unset GOGC
    echo
}

configure_interface() {
    source "$SBS_CONF"
    cidrs=$(echo "$DEVICE_IPS" | tr ' ' '\n' | grep / | xargs)
    echo
    [ -n "$DEVICE_IPS" ] && [ -n "$cidrs" ] && echo "$MESSAGE43
 $DEVICE_IPS

$MESSAGE84"
    [ -n "$DEVICE_IPS" ] && [ -z "$cidrs" ] && echo "$MESSAGE43
 $DEVICE_IPS

$MESSAGE38"
    [ -z "$DEVICE_IPS" ] && echo "$MESSAGE39"
    read -p ": " input
    if [ -z "$(echo "$input" | tr -d '[[:space:]]')" ]; then
        echo "$MESSAGE52"
    elif [ "$input" = "0" ]; then
        sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"\"|" "$SBS_CONF"
        sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"\"|" "$SBS_CONF"
        echo "$MESSAGE53" && return
    elif echo "$input" | grep -q "^0[[:space:]][^[:space:]]"; then
        DEVICE_IPS=$(echo "$input" | sed 's/^0[[:space:]]*//')
        sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"$DEVICE_IPS\"|" "$SBS_CONF"
        echo "$MESSAGE54:
 $DEVICE_IPS"
    else
        m_device_ips=""
        p_device_ips=""
        for ip in $input; do
            if echo "$DEVICE_IPS" | grep -qw "$ip"; then
                DEVICE_IPS=$(echo "$DEVICE_IPS" | tr ' ' '\n' | grep -Fvx "$ip" | tr '\n' ' ' | xargs)
                m_device_ips="$m_device_ips $ip"
            else
                DEVICE_IPS="${DEVICE_IPS:+$DEVICE_IPS }$ip"
                p_device_ips="$p_device_ips $ip"
            fi
        done
        sed -i "s|^DEVICE_IPS=\".*\"$|DEVICE_IPS=\"$DEVICE_IPS\"|" "$SBS_CONF"
        [ -n "$m_device_ips" ] && { m_device_ips=$(echo "$m_device_ips" | xargs); echo "$MESSAGE50
 $m_device_ips"; }
        [ -n "$p_device_ips" ] && { p_device_ips=$(echo "$p_device_ips" | xargs); echo "$MESSAGE51
 $p_device_ips"; }
    fi

    cidrs=$(echo "$DEVICE_IPS" | tr ' ' '\n' | grep / | xargs)

    if [ -n "$cidrs" ]; then
        EXC_DEVICE_IPS=$(for exc in $EXC_DEVICE_IPS; do
            for subnet in $cidrs; do
                cidr_in_cidr "$exc" "$subnet" && echo "$exc" && break
            done
        done | xargs)
        sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"$EXC_DEVICE_IPS\"|" "$SBS_CONF"
        echo
        echo "$MESSAGE56
 $cidrs"
        [ -n "$EXC_DEVICE_IPS" ] && echo "$MESSAGE60
 $EXC_DEVICE_IPS

$MESSAGE57"
        [ -z "$EXC_DEVICE_IPS" ] && echo "$MESSAGE58"
        read -p ": " exc_input
        orig_exc_input="$exc_input"
        ips_part=$(echo "$exc_input" | sed 's/^0[[:space:]]*//')
        if [ -n "$ips_part" ]; then
            exc_input=$(for exci in $ips_part; do
                for subnet in $cidrs; do
                    cidr_in_cidr "$exci" "$subnet" && echo "$exci" && break
                done
            done | xargs)
            prefix=$(echo "$orig_exc_input" | sed -n 's/^\(0[[:space:]]*\).*/\1/p')
            exc_input="$prefix$exc_input"
        else
            exc_input="$orig_exc_input"
        fi
        if [ -z "$(echo "$exc_input" | tr -d '[[:space:]]')" ]; then
            echo "$MESSAGE52"
        elif [ "$exc_input" = "0" ]; then
            sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"\"|" "$SBS_CONF"
            echo "$MESSAGE64"
        elif echo "$exc_input" | grep -q "^0[[:space:]][^[:space:]]"; then
            EXC_DEVICE_IPS=$(echo "$exc_input" | sed 's/^0[[:space:]]*//')
            sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"$EXC_DEVICE_IPS\"|" "$SBS_CONF"
            echo "$MESSAGE65:
 $EXC_DEVICE_IPS"
        else
            m_exc_device_ips=""
            p_exc_device_ips=""
            for ip in $exc_input; do
                if echo "$EXC_DEVICE_IPS" | grep -qw "$ip"; then
                    EXC_DEVICE_IPS=$(echo "$EXC_DEVICE_IPS" | tr ' ' '\n' | grep -Fvx "$ip" | tr '\n' ' ' | xargs)
                    m_exc_device_ips="$m_exc_device_ips $ip"
                else
                    EXC_DEVICE_IPS="${EXC_DEVICE_IPS:+$EXC_DEVICE_IPS }$ip"
                    p_exc_device_ips="$p_exc_device_ips $ip"
                fi
            done
            sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"$EXC_DEVICE_IPS\"|" "$SBS_CONF"
            [ -n "$m_exc_device_ips" ] && { m_exc_device_ips=$(echo "$m_exc_device_ips" | xargs); echo "$MESSAGE62
 $m_exc_device_ips"; }
            [ -n "$p_exc_device_ips" ] && { p_exc_device_ips=$(echo "$p_exc_device_ips" | xargs); echo "$MESSAGE63
 $p_exc_device_ips"; }
        fi
    else
        sed -i "s|^EXC_DEVICE_IPS=\".*\"$|EXC_DEVICE_IPS=\"\"|" "$SBS_CONF"
    fi
}

configure_finterface() {
    source "$SBS_CONF"
    fcidrs=$(echo "$DEVICE_FIPS" | tr ' ' '\n' | grep / | xargs)
    echo
    [ -n "$DEVICE_FIPS" ] && [ -n "$fcidrs" ] && echo "$MESSAGE68
 $DEVICE_FIPS

$MESSAGE40"
    [ -n "$DEVICE_FIPS" ] && [ -z "$fcidrs" ] && echo "$MESSAGE68
 $DEVICE_FIPS

$MESSAGE67"
    [ -z "$DEVICE_FIPS" ] && echo "$MESSAGE44"
    read -p ": " finput
    if [ -z "$(echo "$finput" | tr -d '[[:space:]]')" ]; then
        echo "$MESSAGE52"
    elif [ "$finput" = "0" ]; then
        sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"\"|" "$SBS_CONF"
        sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"\"|" "$SBS_CONF"
        echo "$MESSAGE71" && return
    elif echo "$finput" | grep -q "^0[[:space:]][^[:space:]]"; then
        DEVICE_FIPS=$(echo "$finput" | sed 's/^0[[:space:]]*//')
        sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"$DEVICE_FIPS\"|" "$SBS_CONF"
        echo "$MESSAGE72:
 $DEVICE_FIPS"
    else
        m_device_fips=""
        p_device_fips=""
        for fip in $finput; do
            if echo "$DEVICE_FIPS" | grep -qw "$fip"; then
                DEVICE_FIPS=$(echo "$DEVICE_FIPS" | tr ' ' '\n' | grep -Fvx "$fip" | tr '\n' ' ' | xargs)
                m_device_fips="$m_device_fips $fip"
            else
                DEVICE_FIPS="${DEVICE_FIPS:+$DEVICE_FIPS }$fip"
                p_device_fips="$p_device_fips $fip"
            fi
        done
        sed -i "s|^DEVICE_FIPS=\".*\"$|DEVICE_FIPS=\"$DEVICE_FIPS\"|" "$SBS_CONF"
        [ -n "$m_device_fips" ] && { m_device_fips=$(echo "$m_device_fips" | xargs); echo "$MESSAGE69
 $m_device_fips"; }
        [ -n "$p_device_fips" ] && { p_device_fips=$(echo "$p_device_fips" | xargs); echo "$MESSAGE70
 $p_device_fips"; }
    fi

    fcidrs=$(echo "$DEVICE_FIPS" | tr ' ' '\n' | grep / | xargs)

    if [ -n "$fcidrs" ]; then
        EXC_DEVICE_FIPS=$(for fexc in $EXC_DEVICE_FIPS; do
            for fsubnet in $fcidrs; do
                cidr_in_cidr "$fexc" "$fsubnet" && echo "$fexc" && break
            done
        done | xargs)
        sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"$EXC_DEVICE_FIPS\"|" "$SBS_CONF"
        echo
        echo "$MESSAGE73
 $fcidrs"
        [ -n "$EXC_DEVICE_FIPS" ] && echo "$MESSAGE77
 $EXC_DEVICE_FIPS

$MESSAGE45"
        [ -z "$EXC_DEVICE_FIPS" ] && echo "$MESSAGE74"
        read -p ": " exc_finput
        orig_exc_finput="$exc_finput"
        fips_part=$(echo "$exc_finput" | sed 's/^0[[:space:]]*//')
        if [ -n "$fips_part" ]; then
            exc_finput=$(for fexci in $fips_part; do
                for fsubnet in $fcidrs; do
                    cidr_in_cidr "$fexci" "$fsubnet" && echo "$fexci" && break
                done
            done | xargs)
            fprefix=$(echo "$orig_exc_finput" | sed -n 's/^\(0[[:space:]]*\).*/\1/p')
            exc_finput="$fprefix$exc_finput"
        else
            exc_finput="$orig_exc_finput"
        fi
        if [ -z "$(echo "$exc_finput" | tr -d '[[:space:]]')" ]; then
            echo "$MESSAGE52"
        elif [ "$exc_finput" = "0" ]; then
            sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"\"|" "$SBS_CONF"
            echo "$MESSAGE81"
        elif echo "$exc_finput" | grep -q "^0[[:space:]][^[:space:]]"; then
            EXC_DEVICE_FIPS=$(echo "$exc_finput" | sed 's/^0[[:space:]]*//')
            sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"$EXC_DEVICE_FIPS\"|" "$SBS_CONF"
            echo "$MESSAGE82:
 $EXC_DEVICE_FIPS"
        else
            m_exc_device_fips=""
            p_exc_device_fips=""
            for fip in $exc_finput; do
                if echo "$EXC_DEVICE_FIPS" | grep -qw "$fip"; then
                    EXC_DEVICE_FIPS=$(echo "$EXC_DEVICE_FIPS" | tr ' ' '\n' | grep -Fvx "$fip" | tr '\n' ' ' | xargs)
                    m_exc_device_fips="$m_exc_device_fips $fip"
                else
                    EXC_DEVICE_FIPS="${EXC_DEVICE_FIPS:+$EXC_DEVICE_FIPS }$fip"
                    p_exc_device_fips="$p_exc_device_fips $fip"
                fi
            done
            sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"$EXC_DEVICE_FIPS\"|" "$SBS_CONF"
            [ -n "$m_exc_device_fips" ] && { m_exc_device_fips=$(echo "$m_exc_device_fips" | xargs); echo "$MESSAGE79
 $m_exc_device_fips"; }
            [ -n "$p_exc_device_fips" ] && { p_exc_device_fips=$(echo "$p_exc_device_fips" | xargs); echo "$MESSAGE80
 $p_exc_device_fips"; }
        fi
    else
        sed -i "s|^EXC_DEVICE_FIPS=\".*\"$|EXC_DEVICE_FIPS=\"\"|" "$SBS_CONF"
    fi
}

configure_table() {
    source "$SBS_CONF"
    echo
    echo "$MESSAGE83 $ROUTE_TABLE"
    while true; do
        read -p "$MESSAGE86" new_table
        [ -z "$new_table" ] && echo "$MESSAGE52" && break
        ROUTE_TABLE="$new_table"
        sed -i "s|^ROUTE_TABLE=\".*\"$|ROUTE_TABLE=\"$new_table\"|" "$SBS_CONF"
        echo "$MESSAGE87 $ROUTE_TABLE"; break
    done
}

configure_fwmark() {
    source "$SBS_CONF"
    echo
    echo "$MESSAGE197 $FW_MARK"
    while true; do
        read -p "$MESSAGE198" new_fwmark
        [ -z "$new_fwmark" ] && echo "$MESSAGE52" && break
        FW_MARK="$new_fwmark"
        sed -i "s|^FW_MARK=\".*\"$|FW_MARK=\"$new_fwmark\"|" "$SBS_CONF"
        echo "$MESSAGE147 $FW_MARK"; break
    done
}

setup_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"

    echo "$MESSAGE200"
    update_tun_interface
    extract_listen_port TPROXY_PORT tproxy
    fakeip_check
    source "$SBS_CONF"

    if [ -z "$TUN_INTERFACE" ] && [ -z "$TPROXY_PORT" ]; then
        echo
        echo "$MESSAGE88"
        exit 0
    fi
    if [ -z "$FAKEIP_SUBNET" ]; then
        while true; do
            echo
            echo "$MESSAGE91"
            echo
            [ -z "$DEVICE_IPS" ] && echo "$MESSAGE92"
            is_running && echo "$MESSAGE125"
            echo "$MESSAGE93"
            echo "2. $MESSAGE94"
            read -p "$MESSAGE99" if_choice
            [ -z "$if_choice" ] && echo "$MESSAGE95" && break
            case "$if_choice" in
                1) is_running && stop_sing_box; configure_interface; source "$SBS_CONF" ;;
                2) setup_pro ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    else
        while true; do
            echo
            echo "$MESSAGE91"
            echo
            [ -z "$DEVICE_IPS" ] && [ -z "$DEVICE_FIPS" ] && echo "$MESSAGE96"
            is_running && echo "$MESSAGE41"
            echo "$MESSAGE93"
            echo "$MESSAGE97"
            echo "3. $MESSAGE94"
            read -p "$MESSAGE99" if_choice
            [ -z "$if_choice" ] && echo "$MESSAGE95" && break
            case "$if_choice" in
                1) is_running && stop_sing_box; configure_interface; source "$SBS_CONF" ;;
                2) is_running && stop_sing_box; configure_finterface; source "$SBS_CONF" ;;
                3) setup_pro ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
    echo
    is_running || sing_box_start
}

setup_pro() {
    while true; do
        echo
        echo "$MESSAGE194"
        echo
        is_running && echo "$MESSAGE103"
        echo "$MESSAGE98"
        echo "$MESSAGE195"
        read -p "$MESSAGE196
: " if_choice
        [ -z "$if_choice" ] && echo "$MESSAGE199" && break
        case "$if_choice" in
            1) is_running && stop_sing_box; configure_table; source "$SBS_CONF" ;;
            2) is_running && stop_sing_box; configure_fwmark; source "$SBS_CONF" ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

download_updates() {
    source "$SBS_CONF"
    if [ "$(uname -m)" = "aarch64" ]; then
        SB_ARCHIVE_PATH="$SB_DOWNLOAD_DIR/sing-box-linux-arm64.tar.gz"
        ARCHIVE_SUFFIX="linux-arm64.tar.gz"
    else
        SB_ARCHIVE_PATH="$SB_DOWNLOAD_DIR/sing-box-linux-armv7.tar.gz"
        ARCHIVE_SUFFIX="linux-armv7.tar.gz"
    fi
    if [ "$SB_REPO" = "customa" ] && [ -z "$CUSTOM_REPO_A" ]; then
        sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF"
        SB_REPO="original"
    elif [ "$SB_REPO" = "customb" ] && [ -z "$CUSTOM_REPO_B" ]; then
        sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF"
        SB_REPO="original"
    fi
    if [ "$CORE_VERS" = "given" ] && [ -z "$GIVEN_VERS" ]; then
        sed -i 's|^CORE_VERS="[^"]*"|CORE_VERS="release"|' "$SBS_CONF"
        CORE_VERS="release"
    fi
    UPD_SB_URL=$SB_URL
    if [ "$SB_REPO" = "customa" ]; then
        UPD_SB_URL=$(echo "$SB_URL" | sed "s|SagerNet/sing-box|$CUSTOM_REPO_A|")
    elif [ "$SB_REPO" = "customb" ]; then
        UPD_SB_URL=$(echo "$SB_URL" | sed "s|SagerNet/sing-box|$CUSTOM_REPO_B|")
    fi
    echo
    echo "$MESSAGE100"
    rm -rf "$SB_DOWNLOAD_DIR"
    silent_create_dir "$SB_DOWNLOAD_DIR"
    wget -q -O $TEMP_SCRIPT_PATH "$SCRIPT_URL"

    MAX_RELEASES=${NUM_RELEASES:-30}
    MAX_PAGES=$(( (MAX_RELEASES + 29) / 30 ))
    SB_DOWNLOAD_URL=""
    page=1
    while [ "$page" -le "$MAX_PAGES" ]; do
        json=$(wget --quiet --header="Accept: application/vnd.github.v3+json" -O - "$UPD_SB_URL?page=$page")
        case "$CORE_VERS" in
            release)
                SB_DOWNLOAD_URL=$(awk -v suffix="$ARCHIVE_SUFFIX" '
                    BEGIN { found=0 }
                    /"prerelease": false/ { found=1 }
                    found && /"browser_download_url":/ && $0 ~ suffix {
                        gsub(/^.*"browser_download_url": *"/, "")
                        gsub(/".*$/, "")
                        print
                        exit
                    }
                ' <<EOF
$json
EOF
) ;;
            pre_release)
                SB_DOWNLOAD_URL=$(awk -v suffix="$ARCHIVE_SUFFIX" '
                    BEGIN { found=0 }
                    /"prerelease": true/ { found=1 }
                    found && /"browser_download_url":/ && $0 ~ suffix {
                        gsub(/^.*"browser_download_url": *"/, "")
                        gsub(/".*$/, "")
                        print
                        exit
                    }
                ' <<EOF
$json
EOF
) ;;
            given)
                SB_DOWNLOAD_URL=$(awk -v search="$GIVEN_VERS" -v suffix="$ARCHIVE_SUFFIX" '
                    index($0, "\"browser_download_url\"") && index($0, suffix) && index($0, search) {
                        gsub(/^.*"browser_download_url": *"/, "")
                        gsub(/".*$/, "")
                        print
                        exit
                    }
                ' <<EOF
$json
EOF
) ;;
        esac
        [ -n "$SB_DOWNLOAD_URL" ] && break
        page=$((page + 1))
    done
    ARCHIVE_PATH="$SB_ARCHIVE_PATH"
    DOWNLOAD_URL="$SB_DOWNLOAD_URL"

    if wget --spider -q "$DOWNLOAD_URL"; then
        wget -q -O "$ARCHIVE_PATH" "$DOWNLOAD_URL"
        tar -xzvf "$ARCHIVE_PATH" -C "$SB_DOWNLOAD_DIR" > /dev/null
        echo "$MESSAGE101"
    else
        echo "$MESSAGE219"
    fi
}

update_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    download_updates
    update_sing_box_menu
}

update_sing_box_menu() {
    while true; do
        case "$SB_REPO" in
          original) additionally="$MESSAGE207" ;;
          customa) additionally="$MESSAGE213 A: $CUSTOM_REPO_A" ;;
          customb) additionally="$MESSAGE213 B: $CUSTOM_REPO_B" ;;
        esac
        case "$CORE_VERS" in
          release) given_value="$MESSAGE226" ;;
          pre_release) given_value="$MESSAGE227" ;;
          given) given_value="$MESSAGE228 $GIVEN_VERS" ;;
        esac
        [ -f "$ARCHIVE_PATH" ] && singbox_file=$(find "$SB_DOWNLOAD_DIR" -name "sing-box" -exec test -f {} \; -print) && [ -n "$singbox_file" ] && chmod 775 "$singbox_file"
        sbs_vers=$(get_sbs_version $SCRIPT_PATH)
        if [ -f "$SB_PATH" ]; then
            sb_vers=$(get_sb_version "$SB_PATH")
        else
            sb_vers=""
        fi
        sbs_vers_new=$(get_sbs_version $TEMP_SCRIPT_PATH)
        if [ -f "$singbox_file" ]; then
            sb_vers_new=$(get_sb_version $singbox_file)
        else
            sb_vers_new=""
        fi
        echo
        echo "$MESSAGE102"
        echo
        is_running && echo "$MESSAGE41"
        printf "$MESSAGE104\n" "$sbs_vers" "$sbs_vers_new"
        printf "$MESSAGE105\n" "${sb_vers:-$MESSAGE169}" "${sb_vers_new:-$MESSAGE169.}"
        printf "$MESSAGE235\n" "$additionally" "$given_value"
        if [ -n "$NUM_RELEASES" ]; then
            printf "   $MESSAGE209\n" "$NUM_RELEASES"
        else
            printf "   $MESSAGE209\n" "30"
        fi
        read -p "$MESSAGE99" choice
        [ -z "$choice" ] && { rm -rf "$SB_DOWNLOAD_DIR"; echo "$MESSAGE95"; is_running || sing_box_start; exit 0; }
        case "$choice" in
            1) is_running && stop_sing_box || echo; update_sbs; break ;;
            2) [ -n "$sb_vers_new" ] && { is_running && stop_sing_box || echo; updcore_sing_box; source "$SBS_CONF"; download_updates; continue; } || echo "$MESSAGE219" ;;
            3) change_repo_vers; source "$SBS_CONF"; download_updates; continue ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

change_repo_vers() {
    while true; do
        echo
        echo "$MESSAGE234"
        echo
        printf "$MESSAGE202\n" "$additionally"
        printf "$MESSAGE221\n" "$given_value"
        if [ -n "$NUM_RELEASES" ]; then
            printf "   $MESSAGE209\n" "$NUM_RELEASES"
        else
            printf "   $MESSAGE209\n" "30"
        fi
        read -p "$MESSAGE196: " choice_repo_vers
        [ -z "$choice_repo_vers" ] && echo "$MESSAGE199" && return
        case "$choice_repo_vers" in
            1) change_sing_box_repo; source "$SBS_CONF"; continue ;;
            2) change_core_vers; source "$SBS_CONF"; continue ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

change_sing_box_repo() {
    while true; do
        source "$SBS_CONF"
        [ "$SB_REPO" = "customa" ] && [ -z "$CUSTOM_REPO_A" ] && sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF" && SB_REPO="original"
        [ "$SB_REPO" = "customb" ] && [ -z "$CUSTOM_REPO_B" ] && sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF" && SB_REPO="original"
        case "$SB_REPO" in
          original) additionally="$MESSAGE207" ;;
          customa) additionally="$MESSAGE213 A: $CUSTOM_REPO_A" ;;
          customb) additionally="$MESSAGE213 B: $CUSTOM_REPO_B" ;;
        esac
        echo
        echo "$MESSAGE203"
        echo "$additionally"
        echo "1. $MESSAGE204"
        printf "2. $MESSAGE205\n" "A"
        printf "3. $MESSAGE205\n" "B"
        echo "4. $MESSAGE211 A."
        [ -n "$CUSTOM_REPO_A" ] && printf "   $MESSAGE214\n" ": $CUSTOM_REPO_A"
        echo "5. $MESSAGE211 B."
        [ -n "$CUSTOM_REPO_B" ] && printf "   $MESSAGE214\n" ": $CUSTOM_REPO_B"
        read -p "$MESSAGE196: " choice_repo
        [ -z "$choice_repo" ] && echo "$MESSAGE199" && return
        case "$choice_repo" in
            1) sed -i 's|^SB_REPO="[^"]*"|SB_REPO="original"|' "$SBS_CONF" ;;
            2) [ -n "$CUSTOM_REPO_A" ] && sed -i 's|^SB_REPO="[^"]*"|SB_REPO="customa"|' "$SBS_CONF" || printf "$MESSAGE216\n" "A" ;;
            3) [ -n "$CUSTOM_REPO_B" ] && sed -i 's|^SB_REPO="[^"]*"|SB_REPO="customb"|' "$SBS_CONF" || printf "$MESSAGE216\n" "B" ;;
            4) echo
               echo "$MESSAGE210"
               echo
               read -p "$MESSAGE212 A,
$MESSAGE42
: " newrepoa
               if [ -z "$newrepoa" ]; then
                   echo "$MESSAGE52"
               else
                   if [ "$newrepoa" = "0" ]; then
                       sed -i 's|^CUSTOM_REPO_A="[^"]*"|CUSTOM_REPO_A=""|' "$SBS_CONF"
                       printf "$MESSAGE106\n" "A"
                   elif echo "$newrepoa" | grep -Eqv '^[^[:space:]/]+/[^[:space:]/]+$'; then
                       echo "$MESSAGE217"
                   else
                       sed -i "s|^CUSTOM_REPO_A=\"[^\"]*\"|CUSTOM_REPO_A=\"$newrepoa\"|" "$SBS_CONF"
                       printf "$MESSAGE90\n" "A" "$newrepoa"
                   fi
               fi ;;
            5) echo
               echo "$MESSAGE210"
               echo
               read -p "$MESSAGE212 B,
$MESSAGE42
: " newrepob
               if [ -z "$newrepob" ]; then
                   echo "$MESSAGE52"
               else
                   if [ "$newrepob" = "0" ]; then
                       sed -i 's|^CUSTOM_REPO_B="[^"]*"|CUSTOM_REPO_B=""|' "$SBS_CONF"
                       printf "$MESSAGE106\n" "B"
                   elif echo "$newrepob" | grep -Eqv '^[^[:space:]/]+/[^[:space:]/]+$'; then
                       echo "$MESSAGE217"
                   else
                       sed -i "s|^CUSTOM_REPO_B=\"[^\"]*\"|CUSTOM_REPO_B=\"$newrepob\"|" "$SBS_CONF"
                       printf "$MESSAGE90\n" "B" "$newrepob"
                   fi
               fi ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

change_core_vers() {
    while true; do
        source "$SBS_CONF"
        [ "$CORE_VERS" = "given" ] && [ -z "$GIVEN_VERS" ] && sed -i 's|^CORE_VERS="[^"]*"|CORE_VERS="release"|' "$SBS_CONF" && CORE_VERS="release"
        case "$CORE_VERS" in
          release) given_value="$MESSAGE226" ;;
          pre_release) given_value="$MESSAGE227" ;;
          given) given_value="$MESSAGE228 $GIVEN_VERS" ;;
        esac
        echo
        echo "$MESSAGE229"
        echo "$given_value"
        echo "1. $MESSAGE222"
        echo "2. $MESSAGE223"
        echo "3. $MESSAGE224"
        echo "4. $MESSAGE225"
        [ -n "$GIVEN_VERS" ] && printf "   $MESSAGE214\n" ": $GIVEN_VERS"
        echo "5. $MESSAGE233"
        [ -n "$NUM_RELEASES" ] && { printf "   $MESSAGE214" "$NUM_RELEASES"; echo " $MESSAGE215"; } || { printf "   $MESSAGE214" "30"; echo " $MESSAGE215"; }
        read -p "$MESSAGE196: " choice_vers
        [ -z "$choice_vers" ] && echo "$MESSAGE199" && return
        case "$choice_vers" in
            1) sed -i 's|^CORE_VERS="[^"]*"|CORE_VERS="release"|' "$SBS_CONF" ;;
            2) sed -i 's|^CORE_VERS="[^"]*"|CORE_VERS="pre_release"|' "$SBS_CONF" ;;
            3) [ -n "$GIVEN_VERS" ] && sed -i 's|^CORE_VERS="[^"]*"|CORE_VERS="given"|' "$SBS_CONF" || echo "$MESSAGE231" ;;
            4) echo
               read -p "$MESSAGE232,
$MESSAGE42
: " new_given_vers
               if [ -z "$new_given_vers" ]; then
                   echo "$MESSAGE52"
               else
                   if [ "$new_given_vers" = "0" ]; then
                       sed -i 's|^GIVEN_VERS="[^"]*"|GIVEN_VERS=""|' "$SBS_CONF"
                       echo "$MESSAGE230"
                   else
                       sed -i "s|^GIVEN_VERS=\"[^\"]*\"|GIVEN_VERS=\"$new_given_vers\"|" "$SBS_CONF"
                       echo "$MESSAGE46 $new_given_vers"
                   fi
               fi ;;
            5) echo
               read -p "$MESSAGE208,
$MESSAGE42
: " new_num_releases
               if [ -z "$new_num_releases" ]; then
                   echo "$MESSAGE52"
               else
                   if [ "$new_num_releases" = "0" ]; then
                       sed -i 's|^NUM_RELEASES="[^"]*"|NUM_RELEASES=""|' "$SBS_CONF"
                   else
                       sed -i "s|^NUM_RELEASES=\"[^\"]*\"|NUM_RELEASES=\"$new_num_releases\"|" "$SBS_CONF"
                       printf "$MESSAGE47\n" "$new_num_releases"
                   fi
               fi ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

update_sbs() {
    echo "$MESSAGE107"
    cp $TEMP_SCRIPT_PATH $SCRIPT_PATH
    chmod 775 $SCRIPT_PATH
    [ -f "$LANG_EN" ] && { wget -q -O $LANG_EN $LANG_EN_URL && chmod 664 $LANG_EN; }
    [ -f "$LANG_RU" ] && { wget -q -O $LANG_RU $LANG_RU_URL && chmod 664 $LANG_RU; }

    cat << EOF > $TEMP_UPDATE
#!/bin/sh
exec $SCRIPT_PATH updmonandconf
EOF
    chmod 775 $TEMP_UPDATE
    # Удаляем файл, не используемый с версии 2.2.2
    rm -f $JFFS_SB_DIR/sbs-tmp
    exec $TEMP_UPDATE
}

updmonandconf_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    create_sbs_conf "$TEMP_SBS_CONF"
    comments=$(grep '^#' "$TEMP_SBS_CONF")
    vars_in_tmp=$(grep '^[A-Za-z0-9_]\+=' "$TEMP_SBS_CONF")
    existing_vars=$(grep '^[A-Za-z0-9_]\+=' "$SBS_CONF")
    {
        echo "$comments"
        echo
        for var in $vars_in_tmp; do
            name=$(echo "$var" | cut -d= -f1)
            old_value=$(echo "$existing_vars" | grep "^$name=")
            if [ -n "$old_value" ]; then
                echo "$old_value"
            else
                echo "$var"
            fi
        done
    } > "$SBS_CONF"
    rm -f $TEMP_SBS_CONF

    create_sbs_monitor "$SBS_MON"
    echo "$MESSAGE108"
    exec $SCRIPT_PATH update
}

updcore_sing_box() {
    echo "$MESSAGE109"
    cp "$singbox_file" "$SB_DIR"; echo "$MESSAGE110"
    return
}

check_sing_box() {
    while true; do
        echo; echo "$MESSAGE111"
        if ! output=$($SB_PATH check -c $SB_CONFIG 2>&1); then
            echo "$MESSAGE112"
            echo "$output"
            echo
            echo "$MESSAGE113"
            is_running && echo "$MESSAGE114"
            while true; do
                read -p "$MESSAGE18" choice
                [ -z "$choice" ] && echo "$MESSAGE115" && break
                case "$choice" in
                    1) echo; is_running && stop_sing_box; echo "$MESSAGE116"; nano $SB_CONFIG; echo "$MESSAGE117"; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        else
            echo "$MESSAGE118"; break
        fi
    done
}

format_sing_box() {
    if ! output=$($SB_PATH format -c $SB_CONFIG 2>&1); then
        echo; echo "$MESSAGE112"
        echo "$output"
        echo "$MESSAGE119"
    else
        echo; echo "$MESSAGE120"
        echo "$output"
        while true; do
            echo "$MESSAGE121"
            read -p "$MESSAGE18" save_choice
            [ -z "$save_choice" ] && echo "$MESSAGE122" && break
            case "$save_choice" in
                1) $SB_PATH format -w -c $SB_CONFIG; echo "$MESSAGE123"; break ;;
                *) echo "$MESSAGE6" ;;
            esac
        done
    fi
}

config_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    while true; do
        echo
        echo "$MESSAGE124"
        echo
        is_running && echo "$MESSAGE125" 
        echo "$MESSAGE126"
        echo "$MESSAGE127"
        echo "$MESSAGE128"
        read -p "$MESSAGE99" choice
        [ -z "$choice" ] && echo "$MESSAGE95" && break
        case "$choice" in
            1) is_running && stop_sing_box; echo "$MESSAGE116"; nano $SB_CONFIG; echo "$MESSAGE129" ;;
            2) check_sing_box ;;
            3) format_sing_box ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
    is_running || sing_box_start
}

status_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    echo
    if is_running; then
        echo "$MESSAGE30"
    else
        echo "$MESSAGE37"
    fi
    sbs_version=$(get_sbs_version $SCRIPT_PATH)
    if [ -n "$sbs_version" ]; then
        printf "$MESSAGE130\n" "$sbs_version"
    else
        echo "$MESSAGE131"
    fi
    sb_versplat=$(get_sb_versplat $SB_PATH)
    if [ -n "$sb_versplat" ]; then
        printf "$MESSAGE132\n" "$sb_versplat"
    else
        echo "$MESSAGE133"
    fi
    echo "$MESSAGE134"
    echo "$MESSAGE135"
    is_running && [ -n "$WAN_PORTS" ] && printf "$MESSAGE189\n" "$WAN_PORTS"
    echo
}

server_sing_box() {
    source "$SBS_CONF"
    check_wan_ports
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    echo
    echo "$MESSAGE149"; echo
    echo "$MESSAGE150"
    echo "$MESSAGE151"
    echo "$MESSAGE136"; echo
    while true; do
        source "$SBS_CONF"
        if [ -z "$WAN_PORTS" ]; then
            echo "$MESSAGE142"; echo
            is_running && echo "$MESSAGE154" && echo
            echo "$MESSAGE153"
        else
            printf "$MESSAGE143\n" "$WAN_PORTS"; echo
            is_running && echo "$MESSAGE154" && echo
            echo "$MESSAGE152"
        fi
        read -p ": " input_combinations
        if [ -z "$input_combinations" ]; then
            echo "$MESSAGE52"; echo
            is_running || sing_box_start
            return 0
        fi
        is_running && stop_sing_box || echo
        if [ "$input_combinations" = "0" ]; then
            sed -i "s|^WAN_PORTS=\".*\"$|WAN_PORTS=\"\"|" "$SBS_CONF"
            echo "$MESSAGE144"
        elif echo "$input_combinations" | grep -q "^0[[:space:]]"; then
            input_combinations=$(echo "$input_combinations" | sed 's/^0[[:space:]]*//')
            combinations=$(echo "$input_combinations" | tr ' ' '\n')
            new_ports=""
            for combination in $combinations; do
                if ! is_valid_combs "$combination"; then
                    printf "$MESSAGE138\n" "$combination"
                    continue
                fi
                if ! valid_combs "$combination"; then
                    printf "$MESSAGE139\n" "$combination"
                    continue
                fi
                new_ports="${new_ports:+$new_ports }$combination"
            done
            if [ -n "$new_ports" ]; then
                sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"$new_ports\"|" "$SBS_CONF"
                echo
                printf "$MESSAGE145\n" "$new_ports"
            else
                echo "$MESSAGE146"
            fi
        else
            combinations=$(echo "$input_combinations" | tr ' ' '\n')
            valid_found=0
            valid_list=""
            for combination in $combinations; do
                if ! is_valid_combs "$combination"; then
                    printf "$MESSAGE138\n" "$combination"
                    continue
                fi
                if ! valid_combs "$combination"; then
                    printf "$MESSAGE139\n" "$combination"
                    continue
                fi
                valid_found=1
                valid_list="${valid_list:+$valid_list }$combination"
            done
            if [ "$valid_found" -eq 0 ]; then
                echo "$MESSAGE146"
            fi
            current_ports=$(grep "^WAN_PORTS=" "$SBS_CONF" | cut -d '"' -f2)
            for combination in $valid_list; do
                if echo "$current_ports" | grep -wq "$combination"; then
                    current_ports=$(echo "$current_ports" | sed "s/\b$combination\b//g" | tr -s ' ' | sed 's/^ //')
                    printf "$MESSAGE140\n" "$combination"
                else
                    current_ports="${current_ports:+$current_ports }$combination"
                    printf "$MESSAGE141\n" "$combination"
                fi
            done
            if [ -n "$current_ports" ]; then
                sed -i "s|^WAN_PORTS=.*|WAN_PORTS=\"$current_ports\"|" "$SBS_CONF"
            else
                sed -i "s|^WAN_PORTS=\".*\"$|WAN_PORTS=\"\"|" "$SBS_CONF"
            fi
        fi; echo
    done
}

memlim_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    while true; do
        echo
        echo "$MESSAGE241"
        echo
        echo "   $MESSAGE61:"
        [ -n "$H_MEMLIM" ] && echo "   $MESSAGE4: $H_MEMLIM MiB" || echo "   $MESSAGE4 $MESSAGE19"
        [ -n "$S_MEMLIM" ] && echo "   $MESSAGE9: $S_MEMLIM MiB" || echo "   $MESSAGE9 $MESSAGE19"
        [ -n "$K_GOGC" ] && echo "   GOGC: $K_GOGC" || echo "   GOGC $MESSAGE19"
        echo
        is_running && echo "$MESSAGE125" && echo
        echo "1. $MESSAGE242"
        echo "2. $MESSAGE94"
        read -p "$MESSAGE99" lim_choice
        [ -z "$lim_choice" ] && break
        case "$lim_choice" in
            1) is_running && stop_sing_box || echo; set_easy_memlim; source "$SBS_CONF" ;;
            2) expert_memlim ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
    echo "$MESSAGE95"
    echo
    is_running || sing_box_start
}

set_easy_memlim() {
    echo "$MESSAGE48"
    echo
    while true; do
        [ -n "$H_MEMLIM" ] && echo "$MESSAGE49: $H_MEMLIM MiB" || echo "$MESSAGE49 $MESSAGE76"
        echo
        read -p "$MESSAGE55" new_h_memlim
        [ -z "$new_h_memlim" ] && { echo "$MESSAGE52"; return; }
        if [ "$new_h_memlim" = "0" ]; then
            sed -i "s|^H_MEMLIM=\".*\"$|H_MEMLIM=\"\"|" "$SBS_CONF"
            sed -i "s|^S_MEMLIM=\".*\"$|S_MEMLIM=\"\"|" "$SBS_CONF"
            sed -i "s|^K_GOGC=\".*\"$|K_GOGC=\"\"|" "$SBS_CONF"
            echo "$MESSAGE243"
            return
        fi
        case "$new_h_memlim" in
            *[!0-9]*|0[0-9]*)
                echo "$MESSAGE66"
                continue ;;
        esac
        if [ "$new_h_memlim" -lt 50 ] || [ "$new_h_memlim" -gt 500 ]; then
            echo "$MESSAGE75"
            continue
        fi
        new_s_memlim=$(awk "BEGIN {print int($new_h_memlim/0.9)}")
        sed -i "s|^H_MEMLIM=\".*\"$|H_MEMLIM=\"$new_h_memlim\"|" "$SBS_CONF"
        sed -i "s|^S_MEMLIM=\".*\"$|S_MEMLIM=\"$new_s_memlim\"|" "$SBS_CONF"
        sed -i "s|^K_GOGC=\".*\"$|K_GOGC=\"\"|" "$SBS_CONF"
        echo "$MESSAGE59: $new_h_memlim MiB"
        return
    done
}

expert_memlim() {
    while true; do
        echo
        echo "$MESSAGE78"
        echo
        is_running && echo "$MESSAGE103" && echo
        echo "1. $MESSAGE85"
        [ -n "$H_MEMLIM" ] && echo "   $MESSAGE49: $H_MEMLIM MiB" || echo "   $MESSAGE49 $MESSAGE76"
        echo "2. $MESSAGE89"
        [ -n "$S_MEMLIM" ] && echo "   $MESSAGE49: $S_MEMLIM MiB" || echo "   $MESSAGE49 $MESSAGE76"
        echo "3. $MESSAGE137"
        [ -n "$K_GOGC" ] && echo "   $MESSAGE49: $K_GOGC" || echo "   $MESSAGE49 $MESSAGE76"
        read -p "$MESSAGE196
: " if_choice
        [ -z "$if_choice" ] && break
        case "$if_choice" in
            1) is_running && stop_sing_box || echo; set_h_memlim; source "$SBS_CONF" ;;
            2) is_running && stop_sing_box || echo; set_s_memlim; source "$SBS_CONF" ;;
            3) is_running && stop_sing_box || echo; set_gogc; source "$SBS_CONF" ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

set_h_memlim() {
    echo "$MESSAGE155"
    while true; do
        echo
        [ -n "$H_MEMLIM" ] && echo "$MESSAGE49: $H_MEMLIM MiB" || echo "$MESSAGE49 $MESSAGE76"
        read -p "$MESSAGE156" new_h_memlim
        [ -z "$new_h_memlim" ] && { echo "$MESSAGE52"; return; }
        if [ "$new_h_memlim" = "0" ]; then
            sed -i "s|^H_MEMLIM=\".*\"$|H_MEMLIM=\"\"|" "$SBS_CONF"
            echo "$MESSAGE243"
            return
        fi
        case "$new_h_memlim" in
            *[!0-9]*|0[0-9]*)
                echo "$MESSAGE66"
                continue ;;
        esac
        sed -i "s|^H_MEMLIM=\".*\"$|H_MEMLIM=\"$new_h_memlim\"|" "$SBS_CONF"
        echo "$MESSAGE249: $new_h_memlim MiB"
        return
    done
}

set_s_memlim() {
    echo "$MESSAGE187"
    while true; do
        echo
        [ -n "$S_MEMLIM" ] && echo "$MESSAGE49: $S_MEMLIM MiB" || echo "$MESSAGE49 $MESSAGE76"
        read -p "$MESSAGE156" new_s_memlim
        [ -z "$new_s_memlim" ] && { echo "$MESSAGE52"; return; }
        if [ "$new_s_memlim" = "0" ]; then
            sed -i "s|^S_MEMLIM=\".*\"$|S_MEMLIM=\"\"|" "$SBS_CONF"
            echo "$MESSAGE243"
            return
        fi
        case "$new_s_memlim" in
            *[!0-9]*|0[0-9]*)
                echo "$MESSAGE66"
                continue ;;
        esac
        sed -i "s|^S_MEMLIM=\".*\"$|S_MEMLIM=\"$new_s_memlim\"|" "$SBS_CONF"
        echo "$MESSAGE249: $new_s_memlim MiB"
        return
    done
}

set_gogc() {
    echo "$MESSAGE206"
    while true; do
        echo
        [ -n "$K_GOGC" ] && echo "$MESSAGE49: $K_GOGC" || echo "$MESSAGE49 $MESSAGE76"
        read -p "$MESSAGE218" new_k_gogc
        [ -z "$new_k_gogc" ] && { echo "$MESSAGE52"; return; }
        if [ "$new_k_gogc" = "0" ]; then
            sed -i "s|^K_GOGC=\".*\"$|K_GOGC=\"\"|" "$SBS_CONF"
            echo "$MESSAGE243"
            return
        fi
        case "$new_k_gogc" in
            *[!0-9]*|0[0-9]*)
                echo "$MESSAGE66"
                continue ;;
        esac
        sed -i "s|^K_GOGC=\".*\"$|K_GOGC=\"$new_k_gogc\"|" "$SBS_CONF"
        echo "$MESSAGE249: $new_k_gogc"
        return
    done
}

install_sing_box() {
    rm -f $TEMP_LANG_RU $TEMP_LANG_EN
    echo "Выбор языка / Select language:"
    while true; do
        echo " 1. Русский."
        echo " 2. English."
        read -p "Введите номер пункта / Enter item number: " language_choice
        [ -z "$language_choice" ] && { echo "Пустой ввод. Отмена установки. / Empty input. Cancel installation."; del_if_notcurrent; exit 0; }
        case "$language_choice" in
            1) wget -q -O $TEMP_LANG_RU $LANG_RU_URL && chmod 664 $TEMP_LANG_RU; source "$TEMP_LANG_RU"; break ;;
            2) wget -q -O $TEMP_LANG_EN $LANG_EN_URL && chmod 664 $TEMP_LANG_EN; source "$TEMP_LANG_EN"; break ;;
            *) echo "Некорректный ввод. Попробуйте ещё раз. / Invalid input. Please try again." ;;
        esac
    done

    uname -m | grep -Eq 'arm|aarch' || { echo "$MESSAGE236"; del_if_notcurrent; rm -f $TEMP_LANG_RU $TEMP_LANG_EN; exit 1; }
    { set -- $(uname -r | cut -d. -f1,2 | tr . ' '); [ "$1" -gt 4 ] || [ "$1" -eq 4 -a "$2" -ge 1 ]; } || { echo "$MESSAGE237"; del_if_notcurrent; rm -f $TEMP_LANG_RU $TEMP_LANG_EN; exit 1; }
    { [ -n "$ROOT_DIR" ] && create_or_use_existing "$SB_DIR"; } || { printf "$MESSAGE162\n" "$ROOT_DIR"; del_if_notcurrent; rm -f $TEMP_LANG_RU $TEMP_LANG_EN; exit 1; }

    create_dir "$SB_DOWNLOAD_DIR"
    handle_existing_file "$TEMP_SBS_CONF" create_sbs_conf
    [ -f "$TEMP_LANG_RU" ] && sed -i "s|^LANG=\".*\"$|LANG=\"ru\"|" "$TEMP_SBS_CONF"
    [ -f "$TEMP_LANG_EN" ] && sed -i "s|^LANG=\".*\"$|LANG=\"en\"|" "$TEMP_SBS_CONF"

    echo "$MESSAGE158"
    while true; do
        read -p "$MESSAGE18" choice
        [ -z "$choice" ] && { del_if_notcurrent; [ -f "$SBS_CONF" ] || rm -rf $SB_DIR; rm -f $TEMP_LANG_RU $TEMP_LANG_EN; echo "$MESSAGE159"; exit 0; }
        case $choice in
            1) if is_running; then
                echo "$MESSAGE160"
                while true; do
                   read -p "$MESSAGE18" continue_choice
                   [ -z "$continue_choice" ] && { del_if_notcurrent; rm -rf $SB_DOWNLOAD_DIR $TEMP_LANG_RU $TEMP_LANG_EN; echo "$MESSAGE159"; exit 0; }
                   case "$continue_choice" in
                       1) stop_sing_box; break 2 ;;
                       *) echo "$MESSAGE6" ;;
                   esac
                done
               else
                   break
               fi ;;
            *) echo "$MESSAGE6" ;;
        esac
    done

    echo "$MESSAGE161"
    create_or_use_existing "$JFFS_SB_DIR"
    handle_existing_file "$SCRIPT_PATH" self_copy
    ln -sf $SCRIPT_PATH $LN_PATH
    handle_existing_file "$SBS_MON" create_sbs_monitor
    check_file_existence_and_download "$SB_CONFIG" "$SB_CONFIG_URL"
    chmod 664 "$SB_CONFIG"
    check_copy_file "$TEMP_SBS_CONF" "$SBS_CONF"
    check_copy_file "$TEMP_LANG_RU" "$LANG_RU"
    check_copy_file "$TEMP_LANG_EN" "$LANG_EN"

    if [ "$(uname -m)" = "aarch64" ]; then
        SB_ARCHIVE_PATH="$SB_DOWNLOAD_DIR/sing-box-linux-arm64.tar.gz"
        ARCHIVE_SUFFIX="linux-arm64.tar.gz"
    else
        SB_ARCHIVE_PATH="$SB_DOWNLOAD_DIR/sing-box-linux-armv7.tar.gz"
        ARCHIVE_SUFFIX="linux-armv7.tar.gz"
    fi
    SB_DOWNLOAD_URL=$(wget --quiet --header="Accept: application/vnd.github.v3+json" -O - "$SB_URL" | \
    awk -v suffix="$ARCHIVE_SUFFIX" '
        BEGIN { found=0 }
        /"prerelease": false/ { found=1 }
        found && /"browser_download_url":/ && $0 ~ suffix {
            gsub(/^.*"browser_download_url": *"/, "")
            gsub(/".*$/, "")
            print
            exit
        }
    ')
    DOWNLOAD_URL="$SB_DOWNLOAD_URL"
    ARCHIVE_PATH="$SB_ARCHIVE_PATH"

    echo "$MESSAGE163"
    if wget --spider -q "$DOWNLOAD_URL"; then
        wget -q -O "$ARCHIVE_PATH" "$DOWNLOAD_URL"
        echo "$MESSAGE164"
        tar -xzvf "$ARCHIVE_PATH" -C "$SB_DOWNLOAD_DIR"
        sing_box_file=$(find "$SB_DOWNLOAD_DIR" -name "sing-box" -exec test -f {} \; -print)
        if [ -f "$SB_PATH" ]; then
            echo "$MESSAGE165"
            while true; do
                read -p "$MESSAGE12" choice
                [ -z "$choice" ] && { echo "$MESSAGE13"; break; }
                case $choice in
                    1) cp "$sing_box_file" "$SB_DIR"; chmod 775 "$SB_PATH"; printf "$MESSAGE166\n" "$SB_PATH"; break ;;
                    *) echo "$MESSAGE6" ;;
                esac
            done
        else
            cp "$sing_box_file" "$SB_DIR"; printf "$MESSAGE168\n" "$SB_DIR"
        fi
    else
        [ -f "$SB_PATH" ] && echo "$MESSAGE167 $MESSAGE13" || echo "$MESSAGE167 $MESSAGE220"
    fi
    del_if_notcurrent; rm -rf $SB_DOWNLOAD_DIR $TEMP_LANG_RU $TEMP_LANG_EN
    printf "$MESSAGE170\n" "$SB_DOWNLOAD_DIR"
    echo
    echo "$MESSAGE171"
}

remove_sing_box() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    echo "$MESSAGE172"
    while true; do
        read -p "$MESSAGE18" choice
        [ -z "$choice" ] && echo "$MESSAGE173" && exit 0
        case $choice in
            1) is_running && stop_sing_box; echo "$MESSAGE174"; rm -rf $SB_DIR $JFFS_SB_DIR $LN_PATH; echo "$MESSAGE175"; exit 0 ;;
            *) echo "$MESSAGE6" ;;
        esac
    done
}

show_menu() {
    source "$SBS_CONF"
    [ "$LANG" = "ru" ] && source "$LANG_RU"
    [ "$LANG" = "en" ] && source "$LANG_EN"
    echo
    echo "$MESSAGE176"
    echo
    echo "$MESSAGE178"
    echo "$MESSAGE179"
    echo "$MESSAGE180"
    echo "$MESSAGE184"
    echo "$MESSAGE181"
    echo "$MESSAGE182"
    echo "$MESSAGE240"
    echo "$MESSAGE185"
    echo "$MESSAGE183"
    echo "$MESSAGE157"
    echo "$MESSAGE186"
}

case "$1" in
    install) install_sing_box ;;
    start) start_sing_box ;;
    stop) stop_sing_box ;;
    restart) stop_sing_box; sleep 3; start_sing_box ;;
    status) status_sing_box ;;
    config) config_sing_box ;;
    setup) setup_sing_box ;;
    limit) memlim_sing_box ;;
    server) server_sing_box ;;
    update) update_sing_box ;;
    lang) change_language ;;
    remove) remove_sing_box ;;
    updmonandconf) updmonandconf_sing_box ;;
    *)
    while true; do
        show_menu
        read -p "$MESSAGE177" choice
        [ -z "$choice" ] && echo "$MESSAGE95" && exit 0
        case $choice in
            1) start_sing_box; break ;;
            2) stop_sing_box; break ;;
            3) stop_sing_box; sleep 3; start_sing_box; break ;;
            4) status_sing_box; break ;;
            5) config_sing_box; break ;;
            6) setup_sing_box; break ;;
            7) memlim_sing_box; break ;;
            8) server_sing_box; break ;;
            9) update_sing_box; break ;;
            10) change_language; break ;;
            0) remove_sing_box; break ;;
            *) echo "$MESSAGE6" ;;
        esac
    done ;;
esac

# The developer of script is Dr4tez dr4tez@gmail.com https://github.com/Dr4tez/sing-box4asus
# The sing-box core is used for work https://github.com/SagerNet/sing-box
